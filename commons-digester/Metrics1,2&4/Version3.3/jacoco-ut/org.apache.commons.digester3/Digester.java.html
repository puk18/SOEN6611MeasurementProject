<?xml version="1.0" encoding="iso-8859-1"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Digester.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Apache Commons Digester :: Core</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.digester3</a> &gt; <span class="el_source">Digester.java</span></div><h1>Digester.java</h1><pre class="source lang-java linenums">package org.apache.commons.digester3;

/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * &quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

import static java.lang.String.format;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.lang.reflect.InvocationTargetException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.ArrayList;
import java.util.Collections;
import java.util.EmptyStackException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.validation.Schema;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.DefaultHandler;

/**
 * &lt;p&gt;
 * A &lt;strong&gt;Digester&lt;/strong&gt; processes an XML input stream by matching a series of element nesting patterns to execute
 * Rules that have been added prior to the start of parsing.
 * &lt;/p&gt;
 * &lt;p&gt;
 * See the &lt;a href=&quot;package-summary.html#package_description&quot;&gt;Digester Developer Guide&lt;/a&gt; for more information.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;IMPLEMENTATION NOTE&lt;/strong&gt; - A single Digester instance may only be used within the context of a single
 * thread at a time, and a call to &lt;code&gt;parse()&lt;/code&gt; must be completed before another can be initiated even from the
 * same thread.
 * &lt;/p&gt;
 * &lt;p&gt;
 * A Digester instance should not be used for parsing more than one input document. The problem is that the Digester
 * class has quite a few member variables whose values &quot;evolve&quot; as SAX events are received during a parse. When reusing
 * the Digester instance, all these members must be reset back to their initial states before the second parse begins.
 * The &quot;clear()&quot; method makes a stab at resetting these, but it is actually rather a difficult problem. If you are
 * determined to reuse Digester instances, then at the least you should call the clear() method before each parse, and
 * must call it if the Digester parse terminates due to an exception during a parse.
 * &lt;/p&gt;
 * &lt;p&gt;
 * &lt;strong&gt;LEGACY IMPLEMENTATION NOTE&lt;/strong&gt; - When using the legacy XML schema support (instead of using the
 * {@link Schema} class), a bug in Xerces 2.0.2 prevents the support of XML schema. You need Xerces 2.1/2.3 and up to
 * make this class work with the legacy XML schema support.
 * &lt;/p&gt;
 * &lt;p&gt;
 * This package was inspired by the &lt;code&gt;XmlMapper&lt;/code&gt; class that was part of Tomcat 3.0 and 3.1, but is organized
 * somewhat differently.
 * &lt;/p&gt;
 */
public class Digester
    extends DefaultHandler
{

    // --------------------------------------------------------- Constructors

    /**
     * Construct a new Digester with default properties.
     */
    public Digester()
    {
<span class="fc" id="L106">        super();</span>
<span class="fc" id="L107">    }</span>

    /**
     * Construct a new Digester, allowing a SAXParser to be passed in. This allows Digester to be used in environments
     * which are unfriendly to JAXP1.1 (such as WebLogic 6.0). This may help in places where you are able to load JAXP
     * 1.1 classes yourself.
     *
     * @param parser The SAXParser used to parse XML streams
     */
    public Digester( SAXParser parser )
    {
<span class="nc" id="L118">        super();</span>
<span class="nc" id="L119">        this.parser = parser;</span>
<span class="nc" id="L120">    }</span>

    /**
     * Construct a new Digester, allowing an XMLReader to be passed in. This allows Digester to be used in environments
     * which are unfriendly to JAXP1.1 (such as WebLogic 6.0). Note that if you use this option you have to configure
     * namespace and validation support yourself, as these properties only affect the SAXParser and emtpy constructor.
     *
     * @param reader The XMLReader used to parse XML streams
     */
    public Digester( XMLReader reader )
    {
<span class="fc" id="L131">        super();</span>
<span class="fc" id="L132">        this.reader = reader;</span>
<span class="fc" id="L133">    }</span>

    // --------------------------------------------------- Instance Variables

    /**
     * The body text of the current element.
     */
<span class="pc" id="L140">    private StringBuilder bodyText = new StringBuilder();</span>

    /**
     * The stack of body text string buffers for surrounding elements.
     */
<span class="pc" id="L145">    private final Stack&lt;StringBuilder&gt; bodyTexts = new Stack&lt;StringBuilder&gt;();</span>

    /**
     * Stack whose elements are List objects, each containing a list of Rule objects as returned from Rules.getMatch().
     * As each xml element in the input is entered, the matching rules are pushed onto this stack. After the end tag is
     * reached, the matches are popped again. The depth of is stack is therefore exactly the same as the current
     * &quot;nesting&quot; level of the input xml.
     *
     * @since 1.6
     */
<span class="pc" id="L155">    private final Stack&lt;List&lt;Rule&gt;&gt; matches = new Stack&lt;List&lt;Rule&gt;&gt;();</span>

    /**
     * The class loader to use for instantiating application objects. If not specified, the context class loader, or the
     * class loader used to load Digester itself, is used, based on the value of the &lt;code&gt;useContextClassLoader&lt;/code&gt;
     * variable.
     */
<span class="pc" id="L162">    private ClassLoader classLoader = null;</span>

    /**
     * Has this Digester been configured yet.
     */
<span class="pc" id="L167">    private boolean configured = false;</span>

    /**
     * The EntityResolver used by the SAX parser. By default it use this class
     */
    private EntityResolver entityResolver;

    /**
     * The URLs of entityValidator that have been registered, keyed by the public identifier that corresponds.
     */
<span class="pc" id="L177">    private final HashMap&lt;String, URL&gt; entityValidator = new HashMap&lt;String, URL&gt;();</span>

    /**
     * The application-supplied error handler that is notified when parsing warnings, errors, or fatal errors occur.
     */
<span class="pc" id="L182">    private ErrorHandler errorHandler = null;</span>

    /**
     * The SAXParserFactory that is created the first time we need it.
     */
<span class="pc" id="L187">    private SAXParserFactory factory = null;</span>

    /**
     * The Locator associated with our parser.
     */
<span class="pc" id="L192">    private Locator locator = null;</span>

    /**
     * The current match pattern for nested element processing.
     */
<span class="pc" id="L197">    private String match = &quot;&quot;;</span>

    /**
     * Do we want a &quot;namespace aware&quot; parser.
     */
<span class="pc" id="L202">    private boolean namespaceAware = false;</span>

    /**
     * The executor service to run asynchronous parse method.
     * @since 3.1
     */
    private ExecutorService executorService;

    /**
     * Registered namespaces we are currently processing. The key is the namespace prefix that was declared in the
     * document. The value is an Stack of the namespace URIs this prefix has been mapped to -- the top Stack element is
     * the most current one. (This architecture is required because documents can declare nested uses of the same prefix
     * for different Namespace URIs).
     */
<span class="pc" id="L216">    private final HashMap&lt;String, Stack&lt;String&gt;&gt; namespaces = new HashMap&lt;String, Stack&lt;String&gt;&gt;();</span>

    /**
     * Do we want a &quot;XInclude aware&quot; parser.
     */
<span class="pc" id="L221">    private boolean xincludeAware = false;</span>

    /**
     * The parameters stack being utilized by CallMethodRule and CallParamRule rules.
     *
     * @since 2.0
     */
<span class="pc" id="L228">    private final Stack&lt;Object[]&gt; params = new Stack&lt;Object[]&gt;();</span>

    /**
     * The SAXParser we will use to parse the input stream.
     */
<span class="pc" id="L233">    private SAXParser parser = null;</span>

    /**
     * The public identifier of the DTD we are currently parsing under (if any).
     */
<span class="pc" id="L238">    private String publicId = null;</span>

    /**
     * The XMLReader used to parse digester rules.
     */
<span class="pc" id="L243">    private XMLReader reader = null;</span>

    /**
     * The &quot;root&quot; element of the stack (in other words, the last object that was popped.
     */
<span class="pc" id="L248">    private Object root = null;</span>

    /**
     * The &lt;code&gt;Rules&lt;/code&gt; implementation containing our collection of &lt;code&gt;Rule&lt;/code&gt; instances and associated
     * matching policy. If not established before the first rule is added, a default implementation will be provided.
     */
<span class="pc" id="L254">    private Rules rules = null;</span>

    /**
     * The XML schema to use for validating an XML instance.
     *
     * @since 2.0
     */
<span class="pc" id="L261">    private Schema schema = null;</span>

    /**
     * The object stack being constructed.
     */
<span class="pc" id="L266">    private final Stack&lt;Object&gt; stack = new Stack&lt;Object&gt;();</span>

    /**
     * Do we want to use the Context ClassLoader when loading classes for instantiating new objects. Default is
     * &lt;code&gt;true&lt;/code&gt;.
     */
<span class="pc" id="L272">    private boolean useContextClassLoader = true;</span>

    /**
     * Do we want to use a validating parser.
     */
<span class="pc" id="L277">    private boolean validating = false;</span>

    /**
     * The Log to which most logging calls will be made.
     */
<span class="pc" id="L282">    private Log log = LogFactory.getLog( &quot;org.apache.commons.digester3.Digester&quot; );</span>

    /**
     * The Log to which all SAX event related logging calls will be made.
     */
<span class="pc" id="L287">    private Log saxLog = LogFactory.getLog( &quot;org.apache.commons.digester3.Digester.sax&quot; );</span>

    /**
     * The schema language supported. By default, we use this one.
     */
    protected static final String W3C_XML_SCHEMA = &quot;http://www.w3.org/2001/XMLSchema&quot;;

    /**
     * An optional class that substitutes values in attributes and body text. This may be null and so a null check is
     * always required before use.
     */
    private Substitutor substitutor;

    /** Stacks used for interrule communication, indexed by name String */
<span class="pc" id="L301">    private final HashMap&lt;String, Stack&lt;Object&gt;&gt; stacksByName = new HashMap&lt;String, Stack&lt;Object&gt;&gt;();</span>

    /**
     * If not null, then calls by the parser to this object's characters, startElement, endElement and
     * processingInstruction methods are forwarded to the specified object. This is intended to allow rules to
     * temporarily &quot;take control&quot; of the sax events. In particular, this is used by NodeCreateRule.
     * &lt;p&gt;
     * See setCustomContentHandler.
     */
<span class="pc" id="L310">    private ContentHandler customContentHandler = null;</span>

    /**
     * Object which will receive callbacks for every pop/push action on the default stack or named stacks.
     */
<span class="pc" id="L315">    private StackAction stackAction = null;</span>

    // ------------------------------------------------------------- Properties

    /**
     * Return the currently mapped namespace URI for the specified prefix, if any; otherwise return &lt;code&gt;null&lt;/code&gt;.
     * These mappings come and go dynamically as the document is parsed.
     *
     * @param prefix Prefix to look up
     * @return the currently mapped namespace URI for the specified prefix
     */
    public String findNamespaceURI( String prefix )
    {
<span class="nc" id="L328">        Stack&lt;String&gt; nsStack = namespaces.get( prefix );</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        if ( nsStack == null )</span>
        {
<span class="nc" id="L331">            return null;</span>
        }
        try
        {
<span class="nc" id="L335">            return ( nsStack.peek() );</span>
        }
<span class="nc" id="L337">        catch ( EmptyStackException e )</span>
        {
<span class="nc" id="L339">            return null;</span>
        }
    }

    /**
     * Return the class loader to be used for instantiating application objects when required. This is determined based
     * upon the following rules:
     * &lt;ul&gt;
     * &lt;li&gt;The class loader set by &lt;code&gt;setClassLoader()&lt;/code&gt;, if any&lt;/li&gt;
     * &lt;li&gt;The thread context class loader, if it exists and the &lt;code&gt;useContextClassLoader&lt;/code&gt; property is set to
     * true&lt;/li&gt;
     * &lt;li&gt;The class loader used to load the Digester class itself.
     * &lt;/ul&gt;
     *
     * @return the class loader to be used for instantiating application objects.
     */
    public ClassLoader getClassLoader()
    {
<span class="fc bfc" id="L357" title="All 2 branches covered.">        if ( this.classLoader != null )</span>
        {
<span class="fc" id="L359">            return ( this.classLoader );</span>
        }
<span class="pc bpc" id="L361" title="1 of 2 branches missed.">        if ( this.useContextClassLoader )</span>
        {
<span class="fc" id="L363">            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">            if ( classLoader != null )</span>
            {
<span class="fc" id="L366">                return ( classLoader );</span>
            }
        }
<span class="nc" id="L369">        return ( this.getClass().getClassLoader() );</span>
    }

    /**
     * Set the class loader to be used for instantiating application objects when required.
     *
     * @param classLoader The new class loader to use, or &lt;code&gt;null&lt;/code&gt; to revert to the standard rules
     */
    public void setClassLoader( ClassLoader classLoader )
    {
<span class="fc" id="L379">        this.classLoader = classLoader;</span>
<span class="fc" id="L380">    }</span>

    /**
     * Return the current depth of the element stack.
     *
     * @return the current depth of the element stack.
     */
    public int getCount()
    {
<span class="fc" id="L389">        return ( stack.size() );</span>
    }

    /**
     * Return the name of the XML element that is currently being processed.
     *
     * @return the name of the XML element that is currently being processed.
     */
    public String getCurrentElementName()
    {
<span class="nc" id="L399">        String elementName = match;</span>
<span class="nc" id="L400">        int lastSlash = elementName.lastIndexOf( '/' );</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if ( lastSlash &gt;= 0 )</span>
        {
<span class="nc" id="L403">            elementName = elementName.substring( lastSlash + 1 );</span>
        }
<span class="nc" id="L405">        return ( elementName );</span>
    }

    /**
     * Return the error handler for this Digester.
     *
     * @return the error handler for this Digester.
     */
    public ErrorHandler getErrorHandler()
    {
<span class="fc" id="L415">        return ( this.errorHandler );</span>
    }

    /**
     * Set the error handler for this Digester.
     *
     * @param errorHandler The new error handler
     */
    public void setErrorHandler( ErrorHandler errorHandler )
    {
<span class="fc" id="L425">        this.errorHandler = errorHandler;</span>
<span class="fc" id="L426">    }</span>

    /**
     * Return the SAXParserFactory we will use, creating one if necessary.
     *
     * @return the SAXParserFactory we will use, creating one if necessary.
     */
    public SAXParserFactory getFactory()
    {
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if ( factory == null )</span>
        {
<span class="fc" id="L437">            factory = SAXParserFactory.newInstance();</span>
<span class="fc" id="L438">            factory.setNamespaceAware( namespaceAware );</span>
<span class="fc" id="L439">            factory.setXIncludeAware( xincludeAware );</span>
<span class="fc" id="L440">            factory.setValidating( validating );</span>
<span class="fc" id="L441">            factory.setSchema( schema );</span>
        }
<span class="fc" id="L443">        return ( factory );</span>
    }

    /**
     * Returns a flag indicating whether the requested feature is supported by the underlying implementation of
     * &lt;code&gt;org.xml.sax.XMLReader&lt;/code&gt;. See &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt; for
     * information about the standard SAX2 feature flags.
     *
     * @param feature Name of the feature to inquire about
     * @return true, if the requested feature is supported by the underlying implementation of
     *         &lt;code&gt;org.xml.sax.XMLReader&lt;/code&gt;, false otherwise
     * @throws ParserConfigurationException if a parser configuration error occurs
     * @throws SAXNotRecognizedException if the property name is not recognized
     * @throws SAXNotSupportedException if the property name is recognized but not supported
     */
    public boolean getFeature( String feature )
        throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException
    {
<span class="nc" id="L461">        return ( getFactory().getFeature( feature ) );</span>
    }

    /**
     * Sets a flag indicating whether the requested feature is supported by the underlying implementation of
     * &lt;code&gt;org.xml.sax.XMLReader&lt;/code&gt;. See &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt; for
     * information about the standard SAX2 feature flags. In order to be effective, this method must be called
     * &lt;strong&gt;before&lt;/strong&gt; the &lt;code&gt;getParser()&lt;/code&gt; method is called for the first time, either directly or
     * indirectly.
     *
     * @param feature Name of the feature to set the status for
     * @param value The new value for this feature
     * @throws ParserConfigurationException if a parser configuration error occurs
     * @throws SAXNotRecognizedException if the property name is not recognized
     * @throws SAXNotSupportedException if the property name is recognized but not supported
     */
    public void setFeature( String feature, boolean value )
        throws ParserConfigurationException, SAXNotRecognizedException, SAXNotSupportedException
    {
<span class="nc" id="L480">        getFactory().setFeature( feature, value );</span>
<span class="nc" id="L481">    }</span>

    /**
     * Return the current Logger associated with this instance of the Digester
     *
     * @return the current Logger associated with this instance of the Digester
     */
    public Log getLogger()
    {
<span class="fc" id="L490">        return log;</span>
    }

    /**
     * Set the current logger for this Digester.
     *
     * @param log the current logger for this Digester.
     */
    public void setLogger( Log log )
    {
<span class="nc" id="L500">        this.log = log;</span>
<span class="nc" id="L501">    }</span>

    /**
     * Gets the logger used for logging SAX-related information. &lt;strong&gt;Note&lt;/strong&gt; the output is finely grained.
     *
     * @return the logger used for logging SAX-related information
     * @since 1.6
     */
    public Log getSAXLogger()
    {
<span class="nc" id="L511">        return saxLog;</span>
    }

    /**
     * Sets the logger used for logging SAX-related information. &lt;strong&gt;Note&lt;/strong&gt; the output is finely grained.
     *
     * @param saxLog the logger used for logging SAX-related information, not null
     * @since 1.6
     */
    public void setSAXLogger( Log saxLog )
    {
<span class="nc" id="L522">        this.saxLog = saxLog;</span>
<span class="nc" id="L523">    }</span>

    /**
     * Return the current rule match path
     *
     * @return the current rule match path
     */
    public String getMatch()
    {
<span class="fc" id="L532">        return match;</span>
    }

    /**
     * Return a Stack whose elements are List objects, each containing a list of
     * Rule objects as returned from Rules.getMatch().
     *
     * @return a Stack whose elements are List objects, each containing a list of
     *         Rule objects as returned from Rules.getMatch().
     * @since 3.0
     */
    public Stack&lt;List&lt;Rule&gt;&gt; getMatches()
    {
<span class="nc" id="L545">        return matches;</span>
    }

    /**
     * Return the &quot;namespace aware&quot; flag for parsers we create.
     *
     * @return the &quot;namespace aware&quot; flag for parsers we create.
     */
    public boolean getNamespaceAware()
    {
<span class="fc" id="L555">        return ( this.namespaceAware );</span>
    }

    /**
     * Set the &quot;namespace aware&quot; flag for parsers we create.
     *
     * @param namespaceAware The new &quot;namespace aware&quot; flag
     */
    public void setNamespaceAware( boolean namespaceAware )
    {
<span class="fc" id="L565">        this.namespaceAware = namespaceAware;</span>
<span class="fc" id="L566">    }</span>

    /**
     * Return the XInclude-aware flag for parsers we create. XInclude functionality additionally requires
     * namespace-awareness.
     *
     * @return The XInclude-aware flag
     * @see #getNamespaceAware()
     * @since 2.0
     */
    public boolean getXIncludeAware()
    {
<span class="nc" id="L578">        return ( this.xincludeAware );</span>
    }

    /**
     * Set the XInclude-aware flag for parsers we create. This additionally requires namespace-awareness.
     *
     * @param xincludeAware The new XInclude-aware flag
     * @see #setNamespaceAware(boolean)
     * @since 2.0
     */
    public void setXIncludeAware( boolean xincludeAware )
    {
<span class="nc" id="L590">        this.xincludeAware = xincludeAware;</span>
<span class="nc" id="L591">    }</span>

    /**
     * Set the public id of the current file being parse.
     *
     * @param publicId the DTD/Schema public's id.
     */
    public void setPublicId( String publicId )
    {
<span class="nc" id="L600">        this.publicId = publicId;</span>
<span class="nc" id="L601">    }</span>

    /**
     * Return the public identifier of the DTD we are currently parsing under, if any.
     *
     * @return the public identifier of the DTD we are currently parsing under, if any.
     */
    public String getPublicId()
    {
<span class="nc" id="L610">        return ( this.publicId );</span>
    }

    /**
     * Return the namespace URI that will be applied to all subsequently added &lt;code&gt;Rule&lt;/code&gt; objects.
     *
     * @return the namespace URI that will be applied to all subsequently added &lt;code&gt;Rule&lt;/code&gt; objects.
     */
    public String getRuleNamespaceURI()
    {
<span class="fc" id="L620">        return ( getRules().getNamespaceURI() );</span>
    }

    /**
     * Set the namespace URI that will be applied to all subsequently added &lt;code&gt;Rule&lt;/code&gt; objects.
     *
     * @param ruleNamespaceURI Namespace URI that must match on all subsequently added rules, or &lt;code&gt;null&lt;/code&gt; for
     *            matching regardless of the current namespace URI
     */
    public void setRuleNamespaceURI( String ruleNamespaceURI )
    {
<span class="fc" id="L631">        getRules().setNamespaceURI( ruleNamespaceURI );</span>
<span class="fc" id="L632">    }</span>

    /**
     * Return the SAXParser we will use to parse the input stream.
     *
     * If there is a problem creating the parser, return &lt;code&gt;null&lt;/code&gt;.
     *
     * @return the SAXParser we will use to parse the input stream
     */
    public SAXParser getParser()
    {
        // Return the parser we already created (if any)
<span class="pc bpc" id="L644" title="1 of 2 branches missed.">        if ( parser != null )</span>
        {
<span class="nc" id="L646">            return ( parser );</span>
        }

        // Create a new parser
        try
        {
<span class="fc" id="L652">            parser = getFactory().newSAXParser();</span>
        }
<span class="nc" id="L654">        catch ( Exception e )</span>
        {
<span class="nc" id="L656">            log.error( &quot;Digester.getParser: &quot;, e );</span>
<span class="nc" id="L657">            return ( null );</span>
<span class="fc" id="L658">        }</span>

<span class="fc" id="L660">        return ( parser );</span>
    }

    /**
     * Return the current value of the specified property for the underlying &lt;code&gt;XMLReader&lt;/code&gt; implementation.
     *
     * See &lt;a href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt; for information about the standard SAX2
     * properties.
     *
     * @param property Property name to be retrieved
     * @return the current value of the specified property for the underlying &lt;code&gt;XMLReader&lt;/code&gt; implementation.
     * @throws SAXNotRecognizedException if the property name is not recognized
     * @throws SAXNotSupportedException if the property name is recognized but not supported
     */
    public Object getProperty( String property )
        throws SAXNotRecognizedException, SAXNotSupportedException
    {
<span class="nc" id="L677">        return ( getParser().getProperty( property ) );</span>
    }

    /**
     * Set the current value of the specified property for the underlying &lt;code&gt;XMLReader&lt;/code&gt; implementation. See &lt;a
     * href=&quot;http://www.saxproject.org&quot;&gt;the saxproject website&lt;/a&gt; for information about the standard SAX2 properties.
     *
     * @param property Property name to be set
     * @param value Property value to be set
     * @throws SAXNotRecognizedException if the property name is not recognized
     * @throws SAXNotSupportedException if the property name is recognized but not supported
     */
    public void setProperty( String property, Object value )
        throws SAXNotRecognizedException, SAXNotSupportedException
    {
<span class="nc" id="L692">        getParser().setProperty( property, value );</span>
<span class="nc" id="L693">    }</span>

    /**
     * Return the &lt;code&gt;Rules&lt;/code&gt; implementation object containing our rules collection and associated matching
     * policy. If none has been established, a default implementation will be created and returned.
     *
     * @return the &lt;code&gt;Rules&lt;/code&gt; implementation object.
     */
    public Rules getRules()
    {
<span class="fc bfc" id="L703" title="All 2 branches covered.">        if ( this.rules == null )</span>
        {
<span class="fc" id="L705">            this.rules = new RulesBase();</span>
<span class="fc" id="L706">            this.rules.setDigester( this );</span>
        }
<span class="fc" id="L708">        return ( this.rules );</span>
    }

    /**
     * Set the &lt;code&gt;Rules&lt;/code&gt; implementation object containing our rules collection and associated matching policy.
     *
     * @param rules New Rules implementation
     */
    public void setRules( Rules rules )
    {
<span class="fc" id="L718">        this.rules = rules;</span>
<span class="fc" id="L719">        this.rules.setDigester( this );</span>
<span class="fc" id="L720">    }</span>

    /**
     * Return the XML Schema used when parsing.
     *
     * @return The {@link Schema} instance in use.
     * @since 2.0
     */
    public Schema getXMLSchema()
    {
<span class="nc" id="L730">        return ( this.schema );</span>
    }

    /**
     * Set the XML Schema to be used when parsing.
     *
     * @param schema The {@link Schema} instance to use.
     * @since 2.0
     */
    public void setXMLSchema( Schema schema )
    {
<span class="fc" id="L741">        this.schema = schema;</span>
<span class="fc" id="L742">    }</span>

    /**
     * Return the boolean as to whether the context ClassLoader should be used.
     *
     * @return true, if the context ClassLoader should be used, false otherwise.
     */
    public boolean getUseContextClassLoader()
    {
<span class="nc" id="L751">        return useContextClassLoader;</span>
    }

    /**
     * Determine whether to use the Context ClassLoader (the one found by calling
     * &lt;code&gt;Thread.currentThread().getContextClassLoader()&lt;/code&gt;) to resolve/load classes that are defined in various
     * rules. If not using Context ClassLoader, then the class-loading defaults to using the calling-class' ClassLoader.
     *
     * @param use determines whether to use Context ClassLoader.
     */
    public void setUseContextClassLoader( boolean use )
    {
<span class="nc" id="L763">        useContextClassLoader = use;</span>
<span class="nc" id="L764">    }</span>

    /**
     * Return the validating parser flag.
     *
     * @return the validating parser flag.
     */
    public boolean getValidating()
    {
<span class="fc" id="L773">        return ( this.validating );</span>
    }

    /**
     * Set the validating parser flag. This must be called before &lt;code&gt;parse()&lt;/code&gt; is called the first time. 
     * By default the value of this is set to false.
     * 
     * It essentially just controls the DTD validation. To use modern schema languages use the 
     * {@link #setXMLSchema(Schema)} method to associate a schema to a parser.
     *
     * @param validating The new validating parser flag.
     * @see javax.xml.parsers.SAXParserFactory#setValidating(boolean) for more detail.
     */
    public void setValidating( boolean validating )
    {
<span class="fc" id="L788">        this.validating = validating;</span>
<span class="fc" id="L789">    }</span>

    /**
     * Return the XMLReader to be used for parsing the input document.
     *
     * FIXME: there is a bug in JAXP/XERCES that prevent the use of a parser that contains a schema with a DTD.
     *
     * @return the XMLReader to be used for parsing the input document.
     * @throws SAXException if no XMLReader can be instantiated
     */
    public XMLReader getXMLReader()
        throws SAXException
    {
<span class="fc bfc" id="L802" title="All 2 branches covered.">        if ( reader == null )</span>
        {
<span class="fc" id="L804">            reader = getParser().getXMLReader();</span>
        }

<span class="fc" id="L807">        reader.setDTDHandler( this );</span>
<span class="fc" id="L808">        reader.setContentHandler( this );</span>

<span class="pc bpc" id="L810" title="1 of 2 branches missed.">        if ( entityResolver == null )</span>
        {
<span class="fc" id="L812">            reader.setEntityResolver( this );</span>
        }
        else
        {
<span class="nc" id="L816">            reader.setEntityResolver( entityResolver );</span>
        }

<span class="fc bfc" id="L819" title="All 2 branches covered.">        if ( this.errorHandler != null )</span>
        {
<span class="fc" id="L821">            reader.setErrorHandler( this.errorHandler );</span>
        }
        else
        {
<span class="fc" id="L825">            reader.setErrorHandler( this );</span>
        }

<span class="fc" id="L828">        return reader;</span>
    }

    /**
     * Gets the &lt;code&gt;Substitutor&lt;/code&gt; used to convert attributes and body text.
     *
     * @return the &lt;code&gt;Substitutor&lt;/code&gt; used to convert attributes and body text,
     *         null if not substitutions are to be performed.
     */
    public Substitutor getSubstitutor()
    {
<span class="fc" id="L839">        return substitutor;</span>
    }

    /**
     * Sets the &lt;code&gt;Substitutor&lt;/code&gt; to be used to convert attributes and body text.
     *
     * @param substitutor the Substitutor to be used to convert attributes and body text or null if not substitution of
     *            these values is to be performed.
     */
    public void setSubstitutor( Substitutor substitutor )
    {
<span class="fc" id="L850">        this.substitutor = substitutor;</span>
<span class="fc" id="L851">    }</span>

    /**
     * returns the custom SAX ContentHandler where events are redirected.
     *
     * @return the custom SAX ContentHandler where events are redirected.
     * @see #setCustomContentHandler(ContentHandler)
     * @since 1.7
     */
    public ContentHandler getCustomContentHandler()
    {
<span class="fc" id="L862">        return customContentHandler;</span>
    }

    /**
     * Redirects (or cancels redirecting) of SAX ContentHandler events to an external object.
     * &lt;p&gt;
     * When this object's customContentHandler is non-null, any SAX events received from the parser will simply be
     * passed on to the specified object instead of this object handling them. This allows Rule classes to take control
     * of the SAX event stream for a while in order to do custom processing. Such a rule should save the old value
     * before setting a new one, and restore the old value in order to resume normal digester processing.
     * &lt;p&gt;
     * An example of a Rule which needs this feature is NodeCreateRule.
     * &lt;p&gt;
     * Note that saving the old value is probably not needed as it should always be null; a custom rule that wants to
     * take control could only have been called when there was no custom content handler. But it seems cleaner to
     * properly save/restore the value and maybe some day this will come in useful.
     * &lt;p&gt;
     * Note also that this is not quite equivalent to
     *
     * &lt;pre&gt;
     * digester.getXMLReader().setContentHandler( handler )
     * &lt;/pre&gt;
     *
     * for these reasons:
     * &lt;ul&gt;
     * &lt;li&gt;Some xml parsers don't like having setContentHandler called after parsing has started. The Aelfred parser is
     * one example.&lt;/li&gt;
     * &lt;li&gt;Directing the events via the Digester object potentially allows us to log information about those SAX events
     * at the digester level.&lt;/li&gt;
     * &lt;/ul&gt;
     *
     * @param handler the custom SAX ContentHandler where events are redirected.
     * @since 1.7
     */
    public void setCustomContentHandler( ContentHandler handler )
    {
<span class="fc" id="L898">        customContentHandler = handler;</span>
<span class="fc" id="L899">    }</span>

    /**
     * Define a callback object which is invoked whenever an object is pushed onto a digester object stack,
     * or popped off one.
     *
     * @param stackAction the callback object which is invoked whenever an object is pushed onto a digester
     *        object stack, or popped off one.
     * @since 1.8
     */
    public void setStackAction( StackAction stackAction )
    {
<span class="fc" id="L911">        this.stackAction = stackAction;</span>
<span class="fc" id="L912">    }</span>

    /**
     * Return the callback object which is invoked whenever an object is pushed onto a digester object stack,
     * or popped off one.
     *
     * @return the callback object which is invoked whenever an object is pushed onto a digester object stack,
     *         or popped off one.
     * @see #setStackAction(StackAction)
     * @since 1.8
     */
    public StackAction getStackAction()
    {
<span class="nc" id="L925">        return stackAction;</span>
    }

    /**
     * Get the most current namespaces for all prefixes.
     *
     * @return Map A map with namespace prefixes as keys and most current namespace URIs for the corresponding prefixes
     *         as values
     * @since 1.8
     */
    public Map&lt;String, String&gt; getCurrentNamespaces()
    {
<span class="pc bpc" id="L937" title="1 of 2 branches missed.">        if ( !namespaceAware )</span>
        {
<span class="nc" id="L939">            log.warn( &quot;Digester is not namespace aware&quot; );</span>
        }
<span class="fc" id="L941">        Map&lt;String, String&gt; currentNamespaces = new HashMap&lt;String, String&gt;();</span>
<span class="fc bfc" id="L942" title="All 2 branches covered.">        for ( Map.Entry&lt;String, Stack&lt;String&gt;&gt; nsEntry : namespaces.entrySet() )</span>
        {
            try
            {
<span class="fc" id="L946">                currentNamespaces.put( nsEntry.getKey(), nsEntry.getValue().peek() );</span>
            }
<span class="nc" id="L948">            catch ( RuntimeException e )</span>
            {
                // rethrow, after logging
<span class="nc" id="L951">                log.error( e.getMessage(), e );</span>
<span class="nc" id="L952">                throw e;</span>
<span class="fc" id="L953">            }</span>
<span class="fc" id="L954">        }</span>
<span class="fc" id="L955">        return currentNamespaces;</span>
    }

    /**
     * Returns the executor service used to run asynchronous parse method.
     *
     * @return the executor service used to run asynchronous parse method
     * @since 3.1
     */
    public ExecutorService getExecutorService()
    {
<span class="nc" id="L966">        return executorService;</span>
    }

    /**
     * Sets the executor service to run asynchronous parse method.
     *
     * @param executorService the executor service to run asynchronous parse method
     * @since 3.1
     */
    public void setExecutorService( ExecutorService executorService )
    {
<span class="fc" id="L977">        this.executorService = executorService;</span>
<span class="fc" id="L978">    }</span>

    // ------------------------------------------------- ContentHandler Methods

    /**
     * {@inheritDoc}
     */
    @Override
    public void characters( char buffer[], int start, int length )
        throws SAXException
    {
<span class="fc bfc" id="L989" title="All 2 branches covered.">        if ( customContentHandler != null )</span>
        {
            // forward calls instead of handling them here
<span class="fc" id="L992">            customContentHandler.characters( buffer, start, length );</span>
<span class="fc" id="L993">            return;</span>
        }

<span class="pc bpc" id="L996" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L998">            saxLog.debug( &quot;characters(&quot; + new String( buffer, start, length ) + &quot;)&quot; );</span>
        }

<span class="fc" id="L1001">        bodyText.append( buffer, start, length );</span>
<span class="fc" id="L1002">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void endDocument()
        throws SAXException
    {
<span class="pc bpc" id="L1011" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc bnc" id="L1013" title="All 2 branches missed.">            if ( getCount() &gt; 1 )</span>
            {
<span class="nc" id="L1015">                saxLog.debug( &quot;endDocument():  &quot; + getCount() + &quot; elements left&quot; );</span>
            }
            else
            {
<span class="nc" id="L1019">                saxLog.debug( &quot;endDocument()&quot; );</span>
            }
        }

        // Fire &quot;finish&quot; events for all defined rules
<span class="fc bfc" id="L1024" title="All 2 branches covered.">        for ( Rule rule : getRules().rules() )</span>
        {
            try
            {
<span class="fc" id="L1028">                rule.finish();</span>
            }
<span class="nc" id="L1030">            catch ( Exception e )</span>
            {
<span class="nc" id="L1032">                log.error( &quot;Finish event threw exception&quot;, e );</span>
<span class="nc" id="L1033">                throw createSAXException( e );</span>
            }
<span class="nc" id="L1035">            catch ( Error e )</span>
            {
<span class="nc" id="L1037">                log.error( &quot;Finish event threw error&quot;, e );</span>
<span class="nc" id="L1038">                throw e;</span>
<span class="fc" id="L1039">            }</span>
<span class="fc" id="L1040">        }</span>

        // Perform final cleanup
<span class="fc" id="L1043">        clear();</span>
<span class="fc" id="L1044">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void endElement( String namespaceURI, String localName, String qName )
        throws SAXException
    {
<span class="fc bfc" id="L1053" title="All 2 branches covered.">        if ( customContentHandler != null )</span>
        {
            // forward calls instead of handling them here
<span class="fc" id="L1056">            customContentHandler.endElement( namespaceURI, localName, qName );</span>
<span class="fc" id="L1057">            return;</span>
        }

<span class="fc" id="L1060">        boolean debug = log.isDebugEnabled();</span>

<span class="pc bpc" id="L1062" title="1 of 2 branches missed.">        if ( debug )</span>
        {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">            if ( saxLog.isDebugEnabled() )</span>
            {
<span class="nc" id="L1066">                saxLog.debug( &quot;endElement(&quot; + namespaceURI + &quot;,&quot; + localName + &quot;,&quot; + qName + &quot;)&quot; );</span>
            }
<span class="nc" id="L1068">            log.debug( &quot;  match='&quot; + match + &quot;'&quot; );</span>
<span class="nc" id="L1069">            log.debug( &quot;  bodyText='&quot; + bodyText + &quot;'&quot; );</span>
        }

        // the actual element name is either in localName or qName, depending
        // on whether the parser is namespace aware
<span class="fc" id="L1074">        String name = localName;</span>
<span class="pc bpc" id="L1075" title="1 of 4 branches missed.">        if ( ( name == null ) || ( name.length() &lt; 1 ) )</span>
        {
<span class="fc" id="L1077">            name = qName;</span>
        }

        // Fire &quot;body&quot; events for all relevant rules
<span class="fc" id="L1081">        List&lt;Rule&gt; rules = matches.pop();</span>
<span class="pc bpc" id="L1082" title="1 of 4 branches missed.">        if ( ( rules != null ) &amp;&amp; ( rules.size() &gt; 0 ) )</span>
        {
<span class="fc" id="L1084">            String bodyText = this.bodyText.toString();</span>
<span class="fc" id="L1085">            Substitutor substitutor = getSubstitutor();</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">            if ( substitutor != null )</span>
            {
<span class="fc" id="L1088">                bodyText = substitutor.substitute( bodyText );</span>
            }
<span class="fc bfc" id="L1090" title="All 2 branches covered.">            for ( int i = 0; i &lt; rules.size(); i++ )</span>
            {
                try
                {
<span class="fc" id="L1094">                    Rule rule = rules.get( i );</span>
<span class="pc bpc" id="L1095" title="1 of 2 branches missed.">                    if ( debug )</span>
                    {
<span class="nc" id="L1097">                        log.debug( &quot;  Fire body() for &quot; + rule );</span>
                    }
<span class="fc" id="L1099">                    rule.body( namespaceURI, name, bodyText );</span>
                }
<span class="fc" id="L1101">                catch ( Exception e )</span>
                {
<span class="fc" id="L1103">                    log.error( &quot;Body event threw exception&quot;, e );</span>
<span class="fc" id="L1104">                    throw createSAXException( e );</span>
                }
<span class="nc" id="L1106">                catch ( Error e )</span>
                {
<span class="nc" id="L1108">                    log.error( &quot;Body event threw error&quot;, e );</span>
<span class="nc" id="L1109">                    throw e;</span>
<span class="fc" id="L1110">                }</span>
            }
<span class="fc" id="L1112">        }</span>
        else
        {
<span class="pc bpc" id="L1115" title="1 of 2 branches missed.">            if ( debug )</span>
            {
<span class="nc" id="L1117">                log.debug( &quot;  No rules found matching '&quot; + match + &quot;'.&quot; );</span>
            }
        }

        // Recover the body text from the surrounding element
<span class="fc" id="L1122">        bodyText = bodyTexts.pop();</span>
<span class="pc bpc" id="L1123" title="1 of 2 branches missed.">        if ( debug )</span>
        {
<span class="nc" id="L1125">            log.debug( &quot;  Popping body text '&quot; + bodyText.toString() + &quot;'&quot; );</span>
        }

        // Fire &quot;end&quot; events for all relevant rules in reverse order
<span class="pc bpc" id="L1129" title="1 of 2 branches missed.">        if ( rules != null )</span>
        {
<span class="fc bfc" id="L1131" title="All 2 branches covered.">            for ( int i = 0; i &lt; rules.size(); i++ )</span>
            {
<span class="fc" id="L1133">                int j = ( rules.size() - i ) - 1;</span>
                try
                {
<span class="fc" id="L1136">                    Rule rule = rules.get( j );</span>
<span class="pc bpc" id="L1137" title="1 of 2 branches missed.">                    if ( debug )</span>
                    {
<span class="nc" id="L1139">                        log.debug( &quot;  Fire end() for &quot; + rule );</span>
                    }
<span class="fc" id="L1141">                    rule.end( namespaceURI, name );</span>
                }
<span class="fc" id="L1143">                catch ( Exception e )</span>
                {
<span class="fc" id="L1145">                    log.error( &quot;End event threw exception&quot;, e );</span>
<span class="fc" id="L1146">                    throw createSAXException( e );</span>
                }
<span class="nc" id="L1148">                catch ( Error e )</span>
                {
<span class="nc" id="L1150">                    log.error( &quot;End event threw error&quot;, e );</span>
<span class="nc" id="L1151">                    throw e;</span>
<span class="fc" id="L1152">                }</span>
            }
        }

        // Recover the previous match expression
<span class="fc" id="L1157">        int slash = match.lastIndexOf( '/' );</span>
<span class="fc bfc" id="L1158" title="All 2 branches covered.">        if ( slash &gt;= 0 )</span>
        {
<span class="fc" id="L1160">            match = match.substring( 0, slash );</span>
        }
        else
        {
<span class="fc" id="L1164">            match = &quot;&quot;;</span>
        }
<span class="fc" id="L1166">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void endPrefixMapping( String prefix )
        throws SAXException
    {
<span class="pc bpc" id="L1175" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1177">            saxLog.debug( &quot;endPrefixMapping(&quot; + prefix + &quot;)&quot; );</span>
        }

        // Deregister this prefix mapping
<span class="fc" id="L1181">        Stack&lt;String&gt; stack = namespaces.get( prefix );</span>
<span class="pc bpc" id="L1182" title="1 of 2 branches missed.">        if ( stack == null )</span>
        {
<span class="nc" id="L1184">            return;</span>
        }
        try
        {
<span class="fc" id="L1188">            stack.pop();</span>
<span class="fc bfc" id="L1189" title="All 2 branches covered.">            if ( stack.empty() )</span>
            {
<span class="fc" id="L1191">                namespaces.remove( prefix );</span>
            }
        }
<span class="nc" id="L1194">        catch ( EmptyStackException e )</span>
        {
<span class="nc" id="L1196">            throw createSAXException( &quot;endPrefixMapping popped too many times&quot; );</span>
<span class="fc" id="L1197">        }</span>
<span class="fc" id="L1198">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void ignorableWhitespace( char buffer[], int start, int len )
        throws SAXException
    {
<span class="pc bpc" id="L1207" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1209">            saxLog.debug( &quot;ignorableWhitespace(&quot; + new String( buffer, start, len ) + &quot;)&quot; );</span>
        }

        // No processing required
<span class="fc" id="L1213">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void processingInstruction( String target, String data )
        throws SAXException
    {
<span class="nc bnc" id="L1222" title="All 2 branches missed.">        if ( customContentHandler != null )</span>
        {
            // forward calls instead of handling them here
<span class="nc" id="L1225">            customContentHandler.processingInstruction( target, data );</span>
<span class="nc" id="L1226">            return;</span>
        }

<span class="nc bnc" id="L1229" title="All 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1231">            saxLog.debug( &quot;processingInstruction('&quot; + target + &quot;','&quot; + data + &quot;')&quot; );</span>
        }

        // No processing is required
<span class="nc" id="L1235">    }</span>

    /**
     * Gets the document locator associated with our parser.
     *
     * @return the Locator supplied by the document parser
     */
    public Locator getDocumentLocator()
    {
<span class="fc" id="L1244">        return locator;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void setDocumentLocator( Locator locator )
    {
<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1255">            saxLog.debug( &quot;setDocumentLocator(&quot; + locator + &quot;)&quot; );</span>
        }

<span class="fc" id="L1258">        this.locator = locator;</span>
<span class="fc" id="L1259">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void skippedEntity( String name )
        throws SAXException
    {
<span class="nc bnc" id="L1268" title="All 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1270">            saxLog.debug( &quot;skippedEntity(&quot; + name + &quot;)&quot; );</span>
        }

        // No processing required
<span class="nc" id="L1274">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void startDocument()
        throws SAXException
    {
<span class="pc bpc" id="L1283" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1285">            saxLog.debug( &quot;startDocument()&quot; );</span>
        }

        // ensure that the digester is properly configured, as
        // the digester could be used as a SAX ContentHandler
        // rather than via the parse() methods.
<span class="fc" id="L1291">        configure();</span>
<span class="fc" id="L1292">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void startElement( String namespaceURI, String localName, String qName, Attributes list )
        throws SAXException
    {
<span class="fc" id="L1301">        boolean debug = log.isDebugEnabled();</span>

<span class="fc bfc" id="L1303" title="All 2 branches covered.">        if ( customContentHandler != null )</span>
        {
            // forward calls instead of handling them here
<span class="fc" id="L1306">            customContentHandler.startElement( namespaceURI, localName, qName, list );</span>
<span class="fc" id="L1307">            return;</span>
        }

<span class="pc bpc" id="L1310" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1312">            saxLog.debug( &quot;startElement(&quot; + namespaceURI + &quot;,&quot; + localName + &quot;,&quot; + qName + &quot;)&quot; );</span>
        }

        // Save the body text accumulated for our surrounding element
<span class="fc" id="L1316">        bodyTexts.push( bodyText );</span>
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">        if ( debug )</span>
        {
<span class="nc" id="L1319">            log.debug( &quot;  Pushing body text '&quot; + bodyText.toString() + &quot;'&quot; );</span>
        }
<span class="fc" id="L1321">        bodyText = new StringBuilder();</span>

        // the actual element name is either in localName or qName, depending
        // on whether the parser is namespace aware
<span class="fc" id="L1325">        String name = localName;</span>
<span class="pc bpc" id="L1326" title="1 of 4 branches missed.">        if ( ( name == null ) || ( name.length() &lt; 1 ) )</span>
        {
<span class="fc" id="L1328">            name = qName;</span>
        }

        // Compute the current matching rule
<span class="fc" id="L1332">        StringBuilder sb = new StringBuilder( match );</span>
<span class="fc bfc" id="L1333" title="All 2 branches covered.">        if ( match.length() &gt; 0 )</span>
        {
<span class="fc" id="L1335">            sb.append( '/' );</span>
        }
<span class="fc" id="L1337">        sb.append( name );</span>
<span class="fc" id="L1338">        match = sb.toString();</span>
<span class="pc bpc" id="L1339" title="1 of 2 branches missed.">        if ( debug )</span>
        {
<span class="nc" id="L1341">            log.debug( &quot;  New match='&quot; + match + &quot;'&quot; );</span>
        }

        // Fire &quot;begin&quot; events for all relevant rules
<span class="fc" id="L1345">        List&lt;Rule&gt; rules = getRules().match( namespaceURI, match, localName, list );</span>
<span class="fc" id="L1346">        matches.push( rules );</span>
<span class="pc bpc" id="L1347" title="1 of 4 branches missed.">        if ( ( rules != null ) &amp;&amp; ( rules.size() &gt; 0 ) )</span>
        {
<span class="fc" id="L1349">            Substitutor substitutor = getSubstitutor();</span>
<span class="fc bfc" id="L1350" title="All 2 branches covered.">            if ( substitutor != null )</span>
            {
<span class="fc" id="L1352">                list = substitutor.substitute( list );</span>
            }
<span class="fc bfc" id="L1354" title="All 2 branches covered.">            for ( int i = 0; i &lt; rules.size(); i++ )</span>
            {
                try
                {
<span class="fc" id="L1358">                    Rule rule = rules.get( i );</span>
<span class="pc bpc" id="L1359" title="1 of 2 branches missed.">                    if ( debug )</span>
                    {
<span class="nc" id="L1361">                        log.debug( &quot;  Fire begin() for &quot; + rule );</span>
                    }
<span class="fc" id="L1363">                    rule.begin( namespaceURI, name, list );</span>
                }
<span class="fc" id="L1365">                catch ( Exception e )</span>
                {
<span class="fc" id="L1367">                    log.error( &quot;Begin event threw exception&quot;, e );</span>
<span class="fc" id="L1368">                    throw createSAXException( e );</span>
                }
<span class="nc" id="L1370">                catch ( Error e )</span>
                {
<span class="nc" id="L1372">                    log.error( &quot;Begin event threw error&quot;, e );</span>
<span class="nc" id="L1373">                    throw e;</span>
<span class="fc" id="L1374">                }</span>
            }
<span class="fc" id="L1376">        }</span>
        else
        {
<span class="pc bpc" id="L1379" title="1 of 2 branches missed.">            if ( debug )</span>
            {
<span class="nc" id="L1381">                log.debug( &quot;  No rules found matching '&quot; + match + &quot;'.&quot; );</span>
            }
        }
<span class="fc" id="L1384">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void startPrefixMapping( String prefix, String namespaceURI )
        throws SAXException
    {
<span class="pc bpc" id="L1393" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1395">            saxLog.debug( &quot;startPrefixMapping(&quot; + prefix + &quot;,&quot; + namespaceURI + &quot;)&quot; );</span>
        }

        // Register this prefix mapping
<span class="fc" id="L1399">        Stack&lt;String&gt; stack = namespaces.get( prefix );</span>
<span class="fc bfc" id="L1400" title="All 2 branches covered.">        if ( stack == null )</span>
        {
<span class="fc" id="L1402">            stack = new Stack&lt;String&gt;();</span>
<span class="fc" id="L1403">            namespaces.put( prefix, stack );</span>
        }
<span class="fc" id="L1405">        stack.push( namespaceURI );</span>
<span class="fc" id="L1406">    }</span>

    // ----------------------------------------------------- DTDHandler Methods

    /**
     * {@inheritDoc}
     */
    @Override
    public void notationDecl( String name, String publicId, String systemId )
    {
<span class="nc bnc" id="L1416" title="All 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1418">            saxLog.debug( &quot;notationDecl(&quot; + name + &quot;,&quot; + publicId + &quot;,&quot; + systemId + &quot;)&quot; );</span>
        }
<span class="nc" id="L1420">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void unparsedEntityDecl( String name, String publicId, String systemId, String notation )
    {
<span class="nc bnc" id="L1428" title="All 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1430">            saxLog.debug( &quot;unparsedEntityDecl(&quot; + name + &quot;,&quot; + publicId + &quot;,&quot; + systemId + &quot;,&quot; + notation + &quot;)&quot; );</span>
        }
<span class="nc" id="L1432">    }</span>

    // ----------------------------------------------- EntityResolver Methods

    /**
     * Set the &lt;code&gt;EntityResolver&lt;/code&gt; used by SAX when resolving public id and system id. This must be called
     * before the first call to &lt;code&gt;parse()&lt;/code&gt;.
     *
     * @param entityResolver a class that implement the &lt;code&gt;EntityResolver&lt;/code&gt; interface.
     */
    public void setEntityResolver( EntityResolver entityResolver )
    {
<span class="fc" id="L1444">        this.entityResolver = entityResolver;</span>
<span class="fc" id="L1445">    }</span>

    /**
     * Return the Entity Resolver used by the SAX parser.
     *
     * @return the Entity Resolver used by the SAX parser.
     */
    public EntityResolver getEntityResolver()
    {
<span class="nc" id="L1454">        return entityResolver;</span>
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public InputSource resolveEntity( String publicId, String systemId )
        throws SAXException
    {
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">        if ( saxLog.isDebugEnabled() )</span>
        {
<span class="nc" id="L1466">            saxLog.debug( &quot;resolveEntity('&quot; + publicId + &quot;', '&quot; + systemId + &quot;')&quot; );</span>
        }

<span class="fc bfc" id="L1469" title="All 2 branches covered.">        if ( publicId != null )</span>
        {
<span class="fc" id="L1471">            this.publicId = publicId;</span>
        }

        // Has this system identifier been registered?
<span class="fc" id="L1475">        URL entityURL = null;</span>
<span class="fc bfc" id="L1476" title="All 2 branches covered.">        if ( publicId != null )</span>
        {
<span class="fc" id="L1478">            entityURL = entityValidator.get( publicId );</span>
        }

        // Redirect the schema location to a local destination
<span class="pc bpc" id="L1482" title="1 of 4 branches missed.">        if ( entityURL == null &amp;&amp; systemId != null )</span>
        {
<span class="fc" id="L1484">            entityURL = entityValidator.get( systemId );</span>
        }

<span class="fc bfc" id="L1487" title="All 2 branches covered.">        if ( entityURL == null )</span>
        {
<span class="pc bpc" id="L1489" title="1 of 2 branches missed.">            if ( systemId == null )</span>
            {
                // cannot resolve
<span class="nc bnc" id="L1492" title="All 2 branches missed.">                if ( log.isDebugEnabled() )</span>
                {
<span class="nc" id="L1494">                    log.debug( &quot; Cannot resolve null entity, returning null InputSource&quot; );</span>
                }
<span class="nc" id="L1496">                return ( null );</span>

            }
            // try to resolve using system ID
<span class="pc bpc" id="L1500" title="1 of 2 branches missed.">            if ( log.isDebugEnabled() )</span>
            {
<span class="nc" id="L1502">                log.debug( &quot; Trying to resolve using system ID '&quot; + systemId + &quot;'&quot; );</span>
            }
            try
            {
<span class="fc" id="L1506">                entityURL = new URL( systemId );</span>
            }
<span class="nc" id="L1508">            catch ( MalformedURLException e )</span>
            {
<span class="nc" id="L1510">                throw new IllegalArgumentException( &quot;Malformed URL '&quot; + systemId + &quot;' : &quot; + e.getMessage() );</span>
<span class="fc" id="L1511">            }</span>
        }

        // Return an input source to our alternative URL
<span class="pc bpc" id="L1515" title="1 of 2 branches missed.">        if ( log.isDebugEnabled() )</span>
        {
<span class="nc" id="L1517">            log.debug( &quot; Resolving to alternate DTD '&quot; + entityURL + &quot;'&quot; );</span>
        }

        try
        {
<span class="fc" id="L1522">            return createInputSourceFromURL( entityURL );</span>
        }
<span class="nc" id="L1524">        catch ( Exception e )</span>
        {
<span class="nc" id="L1526">            throw createSAXException( e );</span>
        }
    }

    // ------------------------------------------------- ErrorHandler Methods

    /**
     * {@inheritDoc}
     */
    @Override
    public void error( SAXParseException exception )
        throws SAXException
    {
<span class="fc" id="L1539">    	log.error( &quot;Parse Error at line &quot; + exception.getLineNumber() + &quot; column &quot; + exception.getColumnNumber() + &quot;: &quot;</span>
<span class="fc" id="L1540">                + exception.getMessage(), exception );</span>
<span class="fc" id="L1541">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void fatalError( SAXParseException exception )
        throws SAXException
    {
<span class="fc" id="L1550">        log.error( &quot;Parse Fatal Error at line &quot; + exception.getLineNumber() + &quot; column &quot; + exception.getColumnNumber()</span>
<span class="fc" id="L1551">                + &quot;: &quot; + exception.getMessage(), exception );</span>
<span class="fc" id="L1552">    }</span>

    /**
     * {@inheritDoc}
     */
    @Override
    public void warning( SAXParseException exception )
        throws SAXException
    {
<span class="nc" id="L1561">        log.warn( &quot;Parse Warning Error at line &quot; + exception.getLineNumber() + &quot; column &quot;</span>
<span class="nc" id="L1562">                + exception.getColumnNumber() + &quot;: &quot; + exception.getMessage(), exception );</span>
<span class="nc" id="L1563">    }</span>

    // ------------------------------------------------------- Public Methods

    /**
     * Parse the content of the specified file using this Digester. Returns the root element from the object stack (if
     * any).
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param file File containing the XML data to be parsed
     * @return the root element from the object stack (if any)
     * @throws IOException if an input/output error occurs
     * @throws SAXException if a parsing exception occurs
     */
    public &lt;T&gt; T parse( File file )
        throws IOException, SAXException
    {
<span class="fc bfc" id="L1580" title="All 2 branches covered.">        if ( file == null )</span>
        {
<span class="fc" id="L1582">            throw new IllegalArgumentException( &quot;File to parse is null&quot; );</span>
        }

<span class="fc" id="L1585">        InputSource input = new InputSource( new FileInputStream( file ) );</span>
<span class="fc" id="L1586">        input.setSystemId( file.toURI().toURL().toString() );</span>

<span class="fc" id="L1588">        return ( this.&lt;T&gt; parse( input ) );</span>
    }

    /**
     * Creates a Callable instance that parse the content of the specified reader using this Digester.
     *
     * @param &lt;T&gt; The result type returned by the returned Future's {@code get} method
     * @param file File containing the XML data to be parsed
     * @return a Future that can be used to track when the parse has been fully processed.
     * @see Digester#parse(File)
     * @since 3.1
     */
    public &lt;T&gt; Future&lt;T&gt; asyncParse( final File file )
    {
<span class="fc" id="L1602">        return asyncParse( new Callable&lt;T&gt;()</span>
<span class="fc" id="L1603">        {</span>

            public T call()
                throws Exception
            {
<span class="fc" id="L1608">                return Digester.this.&lt;T&gt; parse( file );</span>
            }

        } );
    }

    /**
     * Parse the content of the specified input source using this Digester. Returns the root element from the object
     * stack (if any).
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param input Input source containing the XML data to be parsed
     * @return the root element from the object stack (if any)
     * @throws IOException if an input/output error occurs
     * @throws SAXException if a parsing exception occurs
     */
    public &lt;T&gt; T parse( InputSource input )
        throws IOException, SAXException
    {
<span class="fc bfc" id="L1627" title="All 2 branches covered.">        if ( input == null )</span>
        {
<span class="fc" id="L1629">            throw new IllegalArgumentException( &quot;InputSource to parse is null&quot; );</span>
        }

<span class="fc" id="L1632">        configure();</span>

<span class="fc" id="L1634">        String systemId = input.getSystemId();</span>
<span class="fc bfc" id="L1635" title="All 2 branches covered.">        if ( systemId == null )</span>
        {
<span class="fc" id="L1637">            systemId = &quot;(already loaded from stream)&quot;;</span>
        }

        try
        {
<span class="fc" id="L1642">            getXMLReader().parse( input );</span>
        }
<span class="nc" id="L1644">        catch ( IOException e )</span>
        {
<span class="nc" id="L1646">            log.error( format( &quot;An error occurred while reading stream from '%s', see nested exceptions&quot;, systemId ),</span>
                       e );
<span class="nc" id="L1648">            throw e;</span>
<span class="fc" id="L1649">        }</span>
<span class="fc" id="L1650">        cleanup();</span>
<span class="fc" id="L1651">        return this.&lt;T&gt; getRoot();</span>
    }

    /**
     * Creates a Callable instance that parse the content of the specified reader using this Digester.
     *
     * @param &lt;T&gt; The result type returned by the returned Future's {@code get} method
     * @param input Input source containing the XML data to be parsed
     * @return a Future that can be used to track when the parse has been fully processed.
     * @see Digester#parse(InputSource)
     * @since 3.1
     */
    public &lt;T&gt; Future&lt;T&gt; asyncParse( final InputSource input )
    {
<span class="fc" id="L1665">        return asyncParse( new Callable&lt;T&gt;()</span>
<span class="fc" id="L1666">        {</span>

            public T call()
                throws Exception
            {
<span class="fc" id="L1671">                return Digester.this.&lt;T&gt; parse( input );</span>
            }

        } );
    }

    /**
     * Parse the content of the specified input stream using this Digester. Returns the root element from the object
     * stack (if any).
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param input Input stream containing the XML data to be parsed
     * @return the root element from the object stack (if any)
     * @throws IOException if an input/output error occurs
     * @throws SAXException if a parsing exception occurs
     */
    public &lt;T&gt; T parse( InputStream input )
        throws IOException, SAXException
    {
<span class="fc bfc" id="L1690" title="All 2 branches covered.">        if ( input == null )</span>
        {
<span class="fc" id="L1692">            throw new IllegalArgumentException( &quot;InputStream to parse is null&quot; );</span>
        }

<span class="fc" id="L1695">        return ( this.&lt;T&gt; parse( new InputSource( input ) ) );</span>
    }

    /**
     * Creates a Callable instance that parse the content of the specified reader using this Digester.
     *
     * @param &lt;T&gt; The result type returned by the returned Future's {@code get} method
     * @param input Input stream containing the XML data to be parsed
     * @return a Future that can be used to track when the parse has been fully processed.
     * @see Digester#parse(InputStream)
     * @since 3.1
     */
    public &lt;T&gt; Future&lt;T&gt; asyncParse( final InputStream input )
    {
<span class="fc" id="L1709">        return asyncParse( new Callable&lt;T&gt;()</span>
<span class="fc" id="L1710">        {</span>

            public T call()
                throws Exception
            {
<span class="fc" id="L1715">                return Digester.this.&lt;T&gt; parse( input );</span>
            }

        } );
    }

    /**
     * Parse the content of the specified reader using this Digester. Returns the root element from the object stack (if
     * any).
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param reader Reader containing the XML data to be parsed
     * @return the root element from the object stack (if any)
     * @throws IOException if an input/output error occurs
     * @throws SAXException if a parsing exception occurs
     */
    public &lt;T&gt; T parse( Reader reader )
        throws IOException, SAXException
    {
<span class="fc bfc" id="L1734" title="All 2 branches covered.">        if ( reader == null )</span>
        {
<span class="fc" id="L1736">            throw new IllegalArgumentException( &quot;Reader to parse is null&quot; );</span>
        }

<span class="fc" id="L1739">        return ( this.&lt;T&gt; parse( new InputSource( reader ) ) );</span>
    }

    /**
     * Creates a Callable instance that parse the content of the specified reader using this Digester.
     *
     * @param &lt;T&gt; The result type returned by the returned Future's {@code get} method
     * @param reader Reader containing the XML data to be parsed
     * @return a Future that can be used to track when the parse has been fully processed.
     * @see Digester#parse(Reader)
     * @since 3.1
     */
    public &lt;T&gt; Future&lt;T&gt; asyncParse( final Reader reader )
    {
<span class="fc" id="L1753">        return asyncParse( new Callable&lt;T&gt;()</span>
<span class="fc" id="L1754">        {</span>

            public T call()
                throws Exception
            {
<span class="fc" id="L1759">                return Digester.this.&lt;T&gt; parse( reader );</span>
            }

        } );
    }

    /**
     * Parse the content of the specified URI using this Digester. Returns the root element from the object stack (if
     * any).
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param uri URI containing the XML data to be parsed
     * @return the root element from the object stack (if any)
     * @throws IOException if an input/output error occurs
     * @throws SAXException if a parsing exception occurs
     */
    public &lt;T&gt; T parse( String uri )
        throws IOException, SAXException
    {
<span class="fc bfc" id="L1778" title="All 2 branches covered.">        if ( uri == null )</span>
        {
<span class="fc" id="L1780">            throw new IllegalArgumentException( &quot;String URI to parse is null&quot; );</span>
        }

<span class="fc" id="L1783">        return ( this.&lt;T&gt; parse( createInputSourceFromURL( uri ) ) );</span>
    }

    /**
     * Creates a Callable instance that parse the content of the specified reader using this Digester.
     *
     * @param &lt;T&gt; The result type returned by the returned Future's {@code get} method
     * @param uri URI containing the XML data to be parsed
     * @return a Future that can be used to track when the parse has been fully processed.
     * @see Digester#parse(String)
     * @since 3.1
     */
    public &lt;T&gt; Future&lt;T&gt; asyncParse( final String uri )
    {
<span class="fc" id="L1797">        return asyncParse( new Callable&lt;T&gt;()</span>
<span class="fc" id="L1798">        {</span>

            public T call()
                throws Exception
            {
<span class="fc" id="L1803">                return Digester.this.&lt;T&gt; parse( uri );</span>
            }

        } );
    }

    /**
     * Parse the content of the specified URL using this Digester. Returns the root element from the object stack (if
     * any).
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param url URL containing the XML data to be parsed
     * @return the root element from the object stack (if any)
     * @throws IOException if an input/output error occurs
     * @throws SAXException if a parsing exception occurs
     * @since 1.8
     */
    public &lt;T&gt; T parse( URL url )
        throws IOException, SAXException
    {
<span class="fc bfc" id="L1823" title="All 2 branches covered.">        if ( url == null )</span>
        {
<span class="fc" id="L1825">            throw new IllegalArgumentException( &quot;URL to parse is null&quot; );</span>
        }

<span class="fc" id="L1828">        return ( this.&lt;T&gt; parse( createInputSourceFromURL( url ) ) );</span>
    }

    /**
     * Creates a Callable instance that parse the content of the specified reader using this Digester.
     *
     * @param &lt;T&gt; The result type returned by the returned Future's {@code get} method
     * @param url URL containing the XML data to be parsed
     * @return a Future that can be used to track when the parse has been fully processed.
     * @see Digester#parse(URL)
     * @since 3.1
     */
    public &lt;T&gt; Future&lt;T&gt; asyncParse( final URL url )
    {
<span class="fc" id="L1842">        return asyncParse( new Callable&lt;T&gt;()</span>
<span class="fc" id="L1843">        {</span>

            public T call()
                throws Exception
            {
<span class="fc" id="L1848">                return Digester.this.&lt;T&gt; parse( url );</span>
            }

        } );
    }

    /**
     * Execute the parse in async mode.
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param callable
     * @return a Future that can be used to track when the parse has been fully processed.
     * @since 3.1
     */
    private &lt;T&gt; Future&lt;T&gt; asyncParse( Callable&lt;T&gt; callable )
    {
<span class="pc bpc" id="L1864" title="1 of 2 branches missed.">        if ( executorService == null )</span>
        {
<span class="nc" id="L1866">            throw new IllegalStateException( &quot;ExecutorService not set&quot; );</span>
        }

<span class="fc" id="L1869">        return executorService.submit( callable );</span>
    }

    /**
     * &lt;p&gt;
     * Register the specified DTD URL for the specified public identifier. This must be called before the first call to
     * &lt;code&gt;parse()&lt;/code&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;code&gt;Digester&lt;/code&gt; contains an internal &lt;code&gt;EntityResolver&lt;/code&gt; implementation. This maps
     * &lt;code&gt;PUBLICID&lt;/code&gt;'s to URLs (from which the resource will be loaded). A common use case for this method is to
     * register local URLs (possibly computed at runtime by a classloader) for DTDs. This allows the performance
     * advantage of using a local version without having to ensure every &lt;code&gt;SYSTEM&lt;/code&gt; URI on every processed xml
     * document is local. This implementation provides only basic functionality. If more sophisticated features are
     * required, using {@link #setEntityResolver} to set a custom resolver is recommended.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; This method will have no effect when a custom &lt;code&gt;EntityResolver&lt;/code&gt; has been set.
     * (Setting a custom &lt;code&gt;EntityResolver&lt;/code&gt; overrides the internal implementation.)
     * &lt;/p&gt;
     *
     * @param publicId Public identifier of the DTD to be resolved
     * @param entityURL The URL to use for reading this DTD
     * @since 1.8
     */
    public void register( String publicId, URL entityURL )
    {
<span class="pc bpc" id="L1896" title="1 of 2 branches missed.">        if ( log.isDebugEnabled() )</span>
        {
<span class="nc" id="L1898">            log.debug( &quot;register('&quot; + publicId + &quot;', '&quot; + entityURL + &quot;'&quot; );</span>
        }
<span class="fc" id="L1900">        entityValidator.put( publicId, entityURL );</span>
<span class="fc" id="L1901">    }</span>

    /**
     * &lt;p&gt;
     * Convenience method that registers the string version of an entity URL instead of a URL version.
     * &lt;/p&gt;
     *
     * @param publicId Public identifier of the entity to be resolved
     * @param entityURL The URL to use for reading this entity
     */
    public void register( String publicId, String entityURL )
    {
<span class="nc bnc" id="L1913" title="All 2 branches missed.">        if ( log.isDebugEnabled() )</span>
        {
<span class="nc" id="L1915">            log.debug( &quot;register('&quot; + publicId + &quot;', '&quot; + entityURL + &quot;'&quot; );</span>
        }
        try
        {
<span class="nc" id="L1919">            entityValidator.put( publicId, new URL( entityURL ) );</span>
        }
<span class="nc" id="L1921">        catch ( MalformedURLException e )</span>
        {
<span class="nc" id="L1923">            throw new IllegalArgumentException( &quot;Malformed URL '&quot; + entityURL + &quot;' : &quot; + e.getMessage() );</span>
<span class="nc" id="L1924">        }</span>
<span class="nc" id="L1925">    }</span>

    /**
     * Convenience method that registers DTD URLs for the specified public identifiers.
     *
     * @param entityValidator The URLs of entityValidator that have been registered, keyed by the public
     *                        identifier that corresponds.
     * @since 3.0
     */
    public void registerAll( Map&lt;String, URL&gt; entityValidator )
    {
<span class="fc" id="L1936">        this.entityValidator.putAll( entityValidator );</span>
<span class="fc" id="L1937">    }</span>

    /**
     * &lt;p&gt;
     * &lt;code&gt;List&lt;/code&gt; of &lt;code&gt;InputSource&lt;/code&gt; instances created by a &lt;code&gt;createInputSourceFromURL()&lt;/code&gt;
     * method call. These represent open input streams that need to be closed to avoid resource leaks, as well as
     * potentially locked JAR files on Windows.
     * &lt;/p&gt;
     */
<span class="pc" id="L1946">    protected List&lt;InputSource&gt; inputSources = new ArrayList&lt;InputSource&gt;( 5 );</span>

    /**
     * Given a URL, return an InputSource that reads from that URL.
     * &lt;p&gt;
     * Ideally this function would not be needed and code could just use &lt;code&gt;new InputSource(entityURL)&lt;/code&gt;.
     * Unfortunately it appears that when the entityURL points to a file within a jar archive a caching mechanism inside
     * the InputSource implementation causes a file-handle to the jar file to remain open. On Windows systems this then
     * causes the jar archive file to be locked on disk (&quot;in use&quot;) which makes it impossible to delete the jar file -
     * and that really stuffs up &quot;undeploy&quot; in webapps in particular.
     * &lt;p&gt;
     * In JDK1.4 and later, Apache XercesJ is used as the xml parser. The InputSource object provided is converted into
     * an XMLInputSource, and eventually passed to an instance of XMLDocumentScannerImpl to specify the source data to
     * be converted into tokens for the rest of the XMLReader code to handle. XMLDocumentScannerImpl calls
     * fEntityManager.startDocumentEntity(source), where fEntityManager is declared in ancestor class XMLScanner to be
     * an XMLEntityManager. In that class, if the input source stream is null, then:
     *
     * &lt;pre&gt;
     * URL location = new URL( expandedSystemId );
     * URLConnection connect = location.openConnection();
     * if ( connect instanceof HttpURLConnection )
     * {
     *     setHttpProperties( connect, xmlInputSource );
     * }
     * stream = connect.getInputStream();
     * &lt;/pre&gt;
     *
     * This method pretty much duplicates the standard behaviour, except that it calls URLConnection.setUseCaches(false)
     * before opening the connection.
     *
     * @param url The URL has to be read
     * @return The InputSource that reads from the input URL
     * @throws IOException if any error occurs while reading the input URL
     * @since 1.8
     */
    public InputSource createInputSourceFromURL( URL url )
        throws IOException
    {
<span class="fc" id="L1984">        URLConnection connection = url.openConnection();</span>
<span class="fc" id="L1985">        connection.setUseCaches( false );</span>
<span class="fc" id="L1986">        InputStream stream = connection.getInputStream();</span>
<span class="fc" id="L1987">        InputSource source = new InputSource( stream );</span>
<span class="fc" id="L1988">        source.setSystemId( url.toExternalForm() );</span>
<span class="fc" id="L1989">        inputSources.add( source );</span>
<span class="fc" id="L1990">        return source;</span>
    }

    /**
     * &lt;p&gt;
     * Convenience method that creates an &lt;code&gt;InputSource&lt;/code&gt; from the string version of a URL.
     * &lt;/p&gt;
     *
     * @param url URL for which to create an &lt;code&gt;InputSource&lt;/code&gt;
     * @return The InputSource that reads from the input URL
     * @throws IOException if any error occurs while reading the input URL
     * @since 1.8
     */
    public InputSource createInputSourceFromURL( String url )
        throws IOException
    {
<span class="fc" id="L2006">        return createInputSourceFromURL( new URL( url ) );</span>
    }

    // --------------------------------------------------------- Rule Methods

    /**
     * &lt;p&gt;
     * Register a new Rule matching the specified pattern. This method sets the &lt;code&gt;Digester&lt;/code&gt; property on the
     * rule.
     * &lt;/p&gt;
     *
     * @param pattern Element matching pattern
     * @param rule Rule to be registered
     */
    public void addRule( String pattern, Rule rule )
    {
<span class="fc" id="L2022">        rule.setDigester( this );</span>
<span class="fc" id="L2023">        getRules().add( pattern, rule );</span>
<span class="fc" id="L2024">    }</span>

    /**
     * Register a set of Rule instances defined in a RuleSet.
     *
     * @param ruleSet The RuleSet instance to configure from
     */
    public void addRuleSet( RuleSet ruleSet )
    {
<span class="fc" id="L2033">        String oldNamespaceURI = getRuleNamespaceURI();</span>
<span class="fc" id="L2034">        String newNamespaceURI = ruleSet.getNamespaceURI();</span>
<span class="pc bpc" id="L2035" title="1 of 2 branches missed.">        if ( log.isDebugEnabled() )</span>
        {
<span class="nc bnc" id="L2037" title="All 2 branches missed.">            if ( newNamespaceURI == null )</span>
            {
<span class="nc" id="L2039">                log.debug( &quot;addRuleSet() with no namespace URI&quot; );</span>
            }
            else
            {
<span class="nc" id="L2043">                log.debug( &quot;addRuleSet() with namespace URI &quot; + newNamespaceURI );</span>
            }
        }
<span class="fc" id="L2046">        setRuleNamespaceURI( newNamespaceURI );</span>
<span class="fc" id="L2047">        ruleSet.addRuleInstances( this );</span>
<span class="fc" id="L2048">        setRuleNamespaceURI( oldNamespaceURI );</span>
<span class="fc" id="L2049">    }</span>

    /**
     * Add a &quot;bean property setter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @see BeanPropertySetterRule
     */
    public void addBeanPropertySetter( String pattern )
    {
<span class="nc" id="L2059">        addRule( pattern, new BeanPropertySetterRule() );</span>
<span class="nc" id="L2060">    }</span>

    /**
     * Add a &quot;bean property setter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param propertyName Name of property to set
     * @see BeanPropertySetterRule
     */
    public void addBeanPropertySetter( String pattern, String propertyName )
    {
<span class="fc" id="L2071">        addRule( pattern, new BeanPropertySetterRule( propertyName ) );</span>
<span class="fc" id="L2072">    }</span>

    /**
     * Add an &quot;call method&quot; rule for a method which accepts no arguments.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @see CallMethodRule
     */
    public void addCallMethod( String pattern, String methodName )
    {
<span class="nc" id="L2083">        addRule( pattern, new CallMethodRule( methodName ) );</span>
<span class="nc" id="L2084">    }</span>

    /**
     * Add an &quot;call method&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @param paramCount Number of expected parameters (or zero for a single parameter from the body of this element)
     * @see CallMethodRule
     */
    public void addCallMethod( String pattern, String methodName, int paramCount )
    {
<span class="fc" id="L2096">        addRule( pattern, new CallMethodRule( methodName, paramCount ) );</span>
<span class="fc" id="L2097">    }</span>

    /**
     * Add an &quot;call method&quot; rule for the specified parameters. If &lt;code&gt;paramCount&lt;/code&gt; is set to zero the rule will
     * use the body of the matched element as the single argument of the method, unless &lt;code&gt;paramTypes&lt;/code&gt; is null
     * or empty, in this case the rule will call the specified method with no arguments.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @param paramCount Number of expected parameters (or zero for a single parameter from the body of this element)
     * @param paramTypes Set of Java class names for the types of the expected parameters (if you wish to use a
     *            primitive type, specify the corresonding Java wrapper class instead, such as
     *            &lt;code&gt;java.lang.Boolean&lt;/code&gt; for a &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see CallMethodRule
     */
    public void addCallMethod( String pattern, String methodName, int paramCount, String paramTypes[] )
    {
<span class="nc" id="L2114">        addRule( pattern, new CallMethodRule( methodName, paramCount, paramTypes ) );</span>
<span class="nc" id="L2115">    }</span>

    /**
     * Add an &quot;call method&quot; rule for the specified parameters. If &lt;code&gt;paramCount&lt;/code&gt; is set to zero the rule will
     * use the body of the matched element as the single argument of the method, unless &lt;code&gt;paramTypes&lt;/code&gt; is null
     * or empty, in this case the rule will call the specified method with no arguments.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to be called
     * @param paramCount Number of expected parameters (or zero for a single parameter from the body of this element)
     * @param paramTypes The Java class names of the arguments (if you wish to use a primitive type, specify the
     *            corresonding Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt; for a
     *            &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see CallMethodRule
     */
    public void addCallMethod( String pattern, String methodName, int paramCount, Class&lt;?&gt; paramTypes[] )
    {
<span class="fc" id="L2132">        addRule( pattern, new CallMethodRule( methodName, paramCount, paramTypes ) );</span>
<span class="fc" id="L2133">    }</span>

    /**
     * Add a &quot;call parameter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param paramIndex Zero-relative parameter index to set (from the body of this element)
     * @see CallParamRule
     */
    public void addCallParam( String pattern, int paramIndex )
    {
<span class="fc" id="L2144">        addRule( pattern, new CallParamRule( paramIndex ) );</span>
<span class="fc" id="L2145">    }</span>

    /**
     * Add a &quot;call parameter&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param paramIndex Zero-relative parameter index to set (from the specified attribute)
     * @param attributeName Attribute whose value is used as the parameter value
     * @see CallParamRule
     */
    public void addCallParam( String pattern, int paramIndex, String attributeName )
    {
<span class="fc" id="L2157">        addRule( pattern, new CallParamRule( paramIndex, attributeName ) );</span>
<span class="fc" id="L2158">    }</span>

    /**
     * Add a &quot;call parameter&quot; rule. This will either take a parameter from the stack or from the current element body
     * text.
     *
     * @param pattern Element matching pattern
     * @param paramIndex The zero-relative parameter number
     * @param fromStack Should the call parameter be taken from the top of the stack?
     * @see CallParamRule
     */
    public void addCallParam( String pattern, int paramIndex, boolean fromStack )
    {
<span class="nc" id="L2171">        addRule( pattern, new CallParamRule( paramIndex, fromStack ) );</span>
<span class="nc" id="L2172">    }</span>

    /**
     * Add a &quot;call parameter&quot; rule that sets a parameter from the stack. This takes a parameter from the given position
     * on the stack.
     *
     * @param pattern Element matching pattern
     * @param paramIndex The zero-relative parameter number
     * @param stackIndex set the call parameter to the stackIndex'th object down the stack, where 0 is the top of the
     *            stack, 1 the next element down and so on
     * @see CallMethodRule
     */
    public void addCallParam( String pattern, int paramIndex, int stackIndex )
    {
<span class="fc" id="L2186">        addRule( pattern, new CallParamRule( paramIndex, stackIndex ) );</span>
<span class="fc" id="L2187">    }</span>

    /**
     * Add a &quot;call parameter&quot; rule that sets a parameter from the current &lt;code&gt;Digester&lt;/code&gt; matching path. This is
     * sometimes useful when using rules that support wildcards.
     *
     * @param pattern the pattern that this rule should match
     * @param paramIndex The zero-relative parameter number
     * @see CallMethodRule
     */
    public void addCallParamPath( String pattern, int paramIndex )
    {
<span class="fc" id="L2199">        addRule( pattern, new PathCallParamRule( paramIndex ) );</span>
<span class="fc" id="L2200">    }</span>

    /**
     * Add a &quot;call parameter&quot; rule that sets a parameter from a caller-provided object. This can be used to pass
     * constants such as strings to methods; it can also be used to pass mutable objects, providing ways for objects to
     * do things like &quot;register&quot; themselves with some shared object.
     * &lt;p&gt;
     * Note that when attempting to locate a matching method to invoke, the true type of the paramObj is used, so that
     * despite the paramObj being passed in here as type Object, the target method can declare its parameters as being
     * the true type of the object (or some ancestor type, according to the usual type-conversion rules).
     *
     * @param pattern Element matching pattern
     * @param paramIndex The zero-relative parameter number
     * @param paramObj Any arbitrary object to be passed to the target method.
     * @see CallMethodRule
     * @since 1.6
     */
    public void addObjectParam( String pattern, int paramIndex, Object paramObj )
    {
<span class="nc" id="L2219">        addRule( pattern, new ObjectParamRule( paramIndex, paramObj ) );</span>
<span class="nc" id="L2220">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters. Exceptions thrown during the object creation process
     * will be propagated.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, String className )
    {
<span class="nc" id="L2232">        addFactoryCreate( pattern, className, false );</span>
<span class="nc" id="L2233">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters. Exceptions thrown during the object creation process
     * will be propagated.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz )
    {
<span class="nc" id="L2245">        addFactoryCreate( pattern, clazz, false );</span>
<span class="nc" id="L2246">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters. Exceptions thrown during the object creation process
     * will be propagated.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the value specified by &lt;code&gt;className&lt;/code&gt;
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, String className, String attributeName )
    {
<span class="nc" id="L2259">        addFactoryCreate( pattern, className, attributeName, false );</span>
<span class="nc" id="L2260">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters. Exceptions thrown during the object creation process
     * will be propagated.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the value specified by &lt;code&gt;className&lt;/code&gt;
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz,
                                  String attributeName )
    {
<span class="nc" id="L2274">        addFactoryCreate( pattern, clazz, attributeName, false );</span>
<span class="nc" id="L2275">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters. Exceptions thrown during the object creation process
     * will be propagated.
     *
     * @param pattern Element matching pattern
     * @param creationFactory Previously instantiated ObjectCreationFactory to be utilized
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, ObjectCreationFactory&lt;?&gt; creationFactory )
    {
<span class="nc" id="L2287">        addFactoryCreate( pattern, creationFactory, false );</span>
<span class="nc" id="L2288">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during object creation will be
     *            ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, String className, boolean ignoreCreateExceptions )
    {
<span class="fc" id="L2301">        addRule( pattern, new FactoryCreateRule( className, ignoreCreateExceptions ) );</span>
<span class="fc" id="L2302">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during object creation will be
     *            ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz,
                                  boolean ignoreCreateExceptions )
    {
<span class="nc" id="L2316">        addRule( pattern, new FactoryCreateRule( clazz, ignoreCreateExceptions ) );</span>
<span class="nc" id="L2317">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Java class name of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the value specified by &lt;code&gt;className&lt;/code&gt;
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during object creation will be
     *            ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, String className, String attributeName,
                                  boolean ignoreCreateExceptions )
    {
<span class="fc" id="L2332">        addRule( pattern, new FactoryCreateRule( className, attributeName, ignoreCreateExceptions ) );</span>
<span class="fc" id="L2333">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class of the object creation factory class
     * @param attributeName Attribute name which, if present, overrides the value specified by &lt;code&gt;className&lt;/code&gt;
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during object creation will be
     *            ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, Class&lt;? extends ObjectCreationFactory&lt;?&gt;&gt; clazz,
                                  String attributeName, boolean ignoreCreateExceptions )
    {
<span class="fc" id="L2348">        addRule( pattern, new FactoryCreateRule( clazz, attributeName, ignoreCreateExceptions ) );</span>
<span class="fc" id="L2349">    }</span>

    /**
     * Add a &quot;factory create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param creationFactory Previously instantiated ObjectCreationFactory to be utilized
     * @param ignoreCreateExceptions when &lt;code&gt;true&lt;/code&gt; any exceptions thrown during object creation will be
     *            ignored.
     * @see FactoryCreateRule
     */
    public void addFactoryCreate( String pattern, ObjectCreationFactory&lt;?&gt; creationFactory,
                                  boolean ignoreCreateExceptions )
    {
<span class="fc" id="L2363">        creationFactory.setDigester( this );</span>
<span class="fc" id="L2364">        addRule( pattern, new FactoryCreateRule( creationFactory, ignoreCreateExceptions ) );</span>
<span class="fc" id="L2365">    }</span>

    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Java class name to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate( String pattern, String className )
    {
<span class="fc" id="L2376">        addRule( pattern, new ObjectCreateRule( className ) );</span>
<span class="fc" id="L2377">    }</span>

    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param clazz Java class to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate( String pattern, Class&lt;?&gt; clazz )
    {
<span class="fc" id="L2388">        addRule( pattern, new ObjectCreateRule( clazz ) );</span>
<span class="fc" id="L2389">    }</span>

    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param className Default Java class name to be created
     * @param attributeName Attribute name that optionally overrides the default Java class name to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate( String pattern, String className, String attributeName )
    {
<span class="nc" id="L2401">        addRule( pattern, new ObjectCreateRule( className, attributeName ) );</span>
<span class="nc" id="L2402">    }</span>

    /**
     * Add an &quot;object create&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param attributeName Attribute name that optionally overrides
     * @param clazz Default Java class to be created the default Java class name to be created
     * @see ObjectCreateRule
     */
    public void addObjectCreate( String pattern, String attributeName, Class&lt;?&gt; clazz )
    {
<span class="nc" id="L2414">        addRule( pattern, new ObjectCreateRule( attributeName, clazz ) );</span>
<span class="nc" id="L2415">    }</span>

    /**
     * Adds an {@link SetNestedPropertiesRule}.
     *
     * @param pattern register the rule with this pattern
     * @since 1.6
     */
    public void addSetNestedProperties( String pattern )
    {
<span class="fc" id="L2425">        addRule( pattern, new SetNestedPropertiesRule() );</span>
<span class="fc" id="L2426">    }</span>

    /**
     * Adds an {@link SetNestedPropertiesRule}.
     *
     * @param pattern register the rule with this pattern
     * @param elementName elment name that a property maps to
     * @param propertyName property name of the element mapped from
     * @since 1.6
     */
    public void addSetNestedProperties( String pattern, String elementName, String propertyName )
    {
<span class="nc" id="L2438">        addRule( pattern, new SetNestedPropertiesRule( elementName, propertyName ) );</span>
<span class="nc" id="L2439">    }</span>

    /**
     * Adds an {@link SetNestedPropertiesRule}.
     *
     * @param pattern register the rule with this pattern
     * @param elementNames elment names that (in order) map to properties
     * @param propertyNames property names that (in order) elements are mapped to
     * @since 1.6
     */
    public void addSetNestedProperties( String pattern, String[] elementNames, String[] propertyNames )
    {
<span class="nc" id="L2451">        addRule( pattern, new SetNestedPropertiesRule( elementNames, propertyNames ) );</span>
<span class="nc" id="L2452">    }</span>

    /**
     * Add a &quot;set next&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @see SetNextRule
     */
    public void addSetNext( String pattern, String methodName )
    {
<span class="fc" id="L2463">        addRule( pattern, new SetNextRule( methodName ) );</span>
<span class="fc" id="L2464">    }</span>

    /**
     * Add a &quot;set next&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @param paramType Java class name of the expected parameter type (if you wish to use a primitive type, specify the
     *            corresonding Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt; for a
     *            &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see SetNextRule
     */
    public void addSetNext( String pattern, String methodName, String paramType )
    {
<span class="nc" id="L2478">        addRule( pattern, new SetNextRule( methodName, paramType ) );</span>
<span class="nc" id="L2479">    }</span>

    /**
     * Add {@link SetRootRule} with the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the root object
     * @see SetRootRule
     */
    public void addSetRoot( String pattern, String methodName )
    {
<span class="fc" id="L2490">        addRule( pattern, new SetRootRule( methodName ) );</span>
<span class="fc" id="L2491">    }</span>

    /**
     * Add {@link SetRootRule} with the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the root object
     * @param paramType Java class name of the expected parameter type
     * @see SetRootRule
     */
    public void addSetRoot( String pattern, String methodName, String paramType )
    {
<span class="nc" id="L2503">        addRule( pattern, new SetRootRule( methodName, paramType ) );</span>
<span class="nc" id="L2504">    }</span>

    /**
     * Add a &quot;set properties&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @see SetPropertiesRule
     */
    public void addSetProperties( String pattern )
    {
<span class="fc" id="L2514">        addRule( pattern, new SetPropertiesRule() );</span>
<span class="fc" id="L2515">    }</span>

    /**
     * Add a &quot;set properties&quot; rule with a single overridden parameter. See
     * {@link SetPropertiesRule#SetPropertiesRule(String attributeName, String propertyName)}
     *
     * @param pattern Element matching pattern
     * @param attributeName map this attribute
     * @param propertyName to this property
     * @see SetPropertiesRule
     */
    public void addSetProperties( String pattern, String attributeName, String propertyName )
    {
<span class="fc" id="L2528">        addRule( pattern, new SetPropertiesRule( attributeName, propertyName ) );</span>
<span class="fc" id="L2529">    }</span>

    /**
     * Add a &quot;set properties&quot; rule with overridden parameters. See
     * {@link SetPropertiesRule#SetPropertiesRule(String [] attributeNames, String [] propertyNames)}
     *
     * @param pattern Element matching pattern
     * @param attributeNames names of attributes with custom mappings
     * @param propertyNames property names these attributes map to
     * @see SetPropertiesRule
     */
    public void addSetProperties( String pattern, String[] attributeNames, String[] propertyNames )
    {
<span class="fc" id="L2542">        addRule( pattern, new SetPropertiesRule( attributeNames, propertyNames ) );</span>
<span class="fc" id="L2543">    }</span>

    /**
     * Add a &quot;set property&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param name Attribute name containing the property name to be set
     * @param value Attribute name containing the property value to set
     * @see SetPropertyRule
     */
    public void addSetProperty( String pattern, String name, String value )
    {
<span class="nc" id="L2555">        addRule( pattern, new SetPropertyRule( name, value ) );</span>
<span class="nc" id="L2556">    }</span>

    /**
     * Add a &quot;set top&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @see SetTopRule
     */
    public void addSetTop( String pattern, String methodName )
    {
<span class="fc" id="L2567">        addRule( pattern, new SetTopRule( methodName ) );</span>
<span class="fc" id="L2568">    }</span>

    /**
     * Add a &quot;set top&quot; rule for the specified parameters.
     *
     * @param pattern Element matching pattern
     * @param methodName Method name to call on the parent element
     * @param paramType Java class name of the expected parameter type (if you wish to use a primitive type, specify the
     *            corresonding Java wrapper class instead, such as &lt;code&gt;java.lang.Boolean&lt;/code&gt; for a
     *            &lt;code&gt;boolean&lt;/code&gt; parameter)
     * @see SetTopRule
     */
    public void addSetTop( String pattern, String methodName, String paramType )
    {
<span class="fc" id="L2582">        addRule( pattern, new SetTopRule( methodName, paramType ) );</span>
<span class="fc" id="L2583">    }</span>

    // --------------------------------------------------- Object Stack Methods

    /**
     * Clear the current contents of the default object stack, the param stack, all named stacks, and other internal
     * variables.
     * &lt;p&gt;
     * Calling this method &lt;i&gt;might&lt;/i&gt; allow another document of the same type to be correctly parsed. However this
     * method was not intended for this purpose (just to tidy up memory usage). In general, a separate Digester object
     * should be created for each document to be parsed.
     * &lt;p&gt;
     * Note that this method is called automatically after a document has been successfully parsed by a Digester
     * instance. However it is not invoked automatically when a parse fails, so when reusing a Digester instance (which
     * is not recommended) this method &lt;i&gt;must&lt;/i&gt; be called manually after a parse failure.
     */
    public void clear()
    {
<span class="fc" id="L2601">        match = &quot;&quot;;</span>
<span class="fc" id="L2602">        bodyTexts.clear();</span>
<span class="fc" id="L2603">        params.clear();</span>
<span class="fc" id="L2604">        publicId = null;</span>
<span class="fc" id="L2605">        stack.clear();</span>
<span class="fc" id="L2606">        stacksByName.clear();</span>
<span class="fc" id="L2607">        customContentHandler = null;</span>
<span class="fc" id="L2608">    }</span>

    /**
     * Return the top object on the stack without removing it.
     *
     * If there are no objects on the stack, return &lt;code&gt;null&lt;/code&gt;.
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @return the top object on the stack without removing it.
     */
    public &lt;T&gt; T peek()
    {
        try
        {
<span class="fc" id="L2622">            return this.&lt;T&gt; npeSafeCast( stack.peek() );</span>
        }
<span class="fc" id="L2624">        catch ( EmptyStackException e )</span>
        {
<span class="fc" id="L2626">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="fc" id="L2627">            return ( null );</span>
        }
    }

    /**
     * Return the n'th object down the stack, where 0 is the top element and [getCount()-1] is the bottom element. If
     * the specified index is out of range, return &lt;code&gt;null&lt;/code&gt;.
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param n Index of the desired element, where 0 is the top of the stack, 1 is the next element down, and so on.
     * @return the n'th object down the stack
     */
    public &lt;T&gt; T peek( int n )
    {
<span class="fc" id="L2641">        int index = ( stack.size() - 1 ) - n;</span>
<span class="fc bfc" id="L2642" title="All 2 branches covered.">        if ( index &lt; 0 )</span>
        {
<span class="fc" id="L2644">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="fc" id="L2645">            return ( null );</span>
        }
        try
        {
<span class="fc" id="L2649">            return this.&lt;T&gt; npeSafeCast( stack.get( index ) );</span>
        }
<span class="nc" id="L2651">        catch ( EmptyStackException e )</span>
        {
<span class="nc" id="L2653">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="nc" id="L2654">            return ( null );</span>
        }
    }

    /**
     * Pop the top object off of the stack, and return it. If there are no objects on the stack, return
     * &lt;code&gt;null&lt;/code&gt;.
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @return the top object popped off of the stack
     */
    public &lt;T&gt; T pop()
    {
        try
        {
<span class="fc" id="L2669">            T popped = this.&lt;T&gt; npeSafeCast( stack.pop() );</span>
<span class="fc bfc" id="L2670" title="All 2 branches covered.">            if ( stackAction != null )</span>
            {
<span class="fc" id="L2672">                popped = stackAction.onPop( this, null, popped );</span>
            }
<span class="fc" id="L2674">            return popped;</span>
        }
<span class="fc" id="L2676">        catch ( EmptyStackException e )</span>
        {
<span class="fc" id="L2678">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="fc" id="L2679">            return ( null );</span>
        }
    }

    /**
     * Push a new object onto the top of the object stack.
     *
     * @param &lt;T&gt; any type of the pushed object
     * @param object The new object
     */
    public &lt;T&gt; void push( T object )
    {
<span class="fc bfc" id="L2691" title="All 2 branches covered.">        if ( stackAction != null )</span>
        {
<span class="fc" id="L2693">            object = stackAction.onPush( this, null, object );</span>
        }

<span class="fc bfc" id="L2696" title="All 2 branches covered.">        if ( stack.size() == 0 )</span>
        {
<span class="fc" id="L2698">            root = object;</span>
        }
<span class="fc" id="L2700">        stack.push( object );</span>
<span class="fc" id="L2701">    }</span>

    /**
     * Pushes the given object onto the stack with the given name. If no stack already exists with the given name then
     * one will be created.
     *
     * @param &lt;T&gt; any type of the pushed object
     * @param stackName the name of the stack onto which the object should be pushed
     * @param value the Object to be pushed onto the named stack.
     * @since 1.6
     */
    public &lt;T&gt; void push( String stackName, T value )
    {
<span class="fc bfc" id="L2714" title="All 2 branches covered.">        if ( stackAction != null )</span>
        {
<span class="fc" id="L2716">            value = stackAction.onPush( this, stackName, value );</span>
        }

<span class="fc" id="L2719">        Stack&lt;Object&gt; namedStack = stacksByName.get( stackName );</span>
<span class="fc bfc" id="L2720" title="All 2 branches covered.">        if ( namedStack == null )</span>
        {
<span class="fc" id="L2722">            namedStack = new Stack&lt;Object&gt;();</span>
<span class="fc" id="L2723">            stacksByName.put( stackName, namedStack );</span>
        }
<span class="fc" id="L2725">        namedStack.push( value );</span>
<span class="fc" id="L2726">    }</span>

    /**
     * &lt;p&gt;
     * Pops (gets and removes) the top object from the stack with the given name.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty if no objects have been pushed onto it yet.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param stackName the name of the stack from which the top value is to be popped.
     * @return the top &lt;code&gt;Object&lt;/code&gt; on the stack or throws {@code EmptyStackException}
     *         if the stack is either empty or has not been created yet
     * @since 1.6
     */
    public &lt;T&gt; T pop( String stackName )
    {
<span class="fc" id="L2744">        T result = null;</span>
<span class="fc" id="L2745">        Stack&lt;Object&gt; namedStack = stacksByName.get( stackName );</span>
<span class="fc bfc" id="L2746" title="All 2 branches covered.">        if ( namedStack == null )</span>
        {
<span class="pc bpc" id="L2748" title="1 of 2 branches missed.">            if ( log.isDebugEnabled() )</span>
            {
<span class="nc" id="L2750">                log.debug( &quot;Stack '&quot; + stackName + &quot;' is empty&quot; );</span>
            }
<span class="fc" id="L2752">            throw new EmptyStackException();</span>
        }

<span class="fc" id="L2755">        result = this.&lt;T&gt; npeSafeCast( namedStack.pop() );</span>

<span class="fc bfc" id="L2757" title="All 2 branches covered.">        if ( stackAction != null )</span>
        {
<span class="fc" id="L2759">            result = stackAction.onPop( this, stackName, result );</span>
        }

<span class="fc" id="L2762">        return result;</span>
    }

    /**
     * &lt;p&gt;
     * Gets the top object from the stack with the given name. This method does not remove the object from the stack.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty if no objects have been pushed onto it yet.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param stackName the name of the stack to be peeked
     * @return the top &lt;code&gt;Object&lt;/code&gt; on the stack or null if the stack is either empty or has not been created yet
     * @since 1.6
     */
    public &lt;T&gt; T peek( String stackName )
    {
<span class="fc" id="L2780">        return this.&lt;T&gt; npeSafeCast( peek( stackName, 0 ) );</span>
    }

    /**
     * &lt;p&gt;
     * Gets the top object from the stack with the given name. This method does not remove the object from the stack.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty if no objects have been pushed onto it yet.
     * &lt;/p&gt;
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @param stackName the name of the stack to be peeked
     * @param n Index of the desired element, where 0 is the top of the stack, 1 is the next element down, and so on.
     * @return the specified &lt;code&gt;Object&lt;/code&gt; on the stack.
     * @since 1.6
     */
    public &lt;T&gt; T peek( String stackName, int n )
    {
<span class="fc" id="L2799">        T result = null;</span>
<span class="fc" id="L2800">        Stack&lt;Object&gt; namedStack = stacksByName.get( stackName );</span>
<span class="fc bfc" id="L2801" title="All 2 branches covered.">        if ( namedStack == null )</span>
        {
<span class="pc bpc" id="L2803" title="1 of 2 branches missed.">            if ( log.isDebugEnabled() )</span>
            {
<span class="nc" id="L2805">                log.debug( &quot;Stack '&quot; + stackName + &quot;' is empty&quot; );</span>
            }
<span class="fc" id="L2807">            throw new EmptyStackException();</span>
        }

<span class="fc" id="L2810">        int index = ( namedStack.size() - 1 ) - n;</span>
<span class="fc bfc" id="L2811" title="All 2 branches covered.">        if ( index &lt; 0 )</span>
        {
<span class="fc" id="L2813">            throw new EmptyStackException();</span>
        }
<span class="fc" id="L2815">        result = this.&lt;T&gt; npeSafeCast( namedStack.get( index ) );</span>

<span class="fc" id="L2817">        return result;</span>
    }

    /**
     * &lt;p&gt;
     * Is the stack with the given name empty?
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note:&lt;/strong&gt; a stack is considered empty if no objects have been pushed onto it yet.
     * &lt;/p&gt;
     *
     * @param stackName the name of the stack whose emptiness should be evaluated
     * @return true if the given stack if empty
     * @since 1.6
     */
    public boolean isEmpty( String stackName )
    {
<span class="fc" id="L2834">        boolean result = true;</span>
<span class="fc" id="L2835">        Stack&lt;Object&gt; namedStack = stacksByName.get( stackName );</span>
<span class="fc bfc" id="L2836" title="All 2 branches covered.">        if ( namedStack != null )</span>
        {
<span class="fc" id="L2838">            result = namedStack.isEmpty();</span>
        }
<span class="fc" id="L2840">        return result;</span>
    }

    /**
     * Returns the root element of the tree of objects created as a result of applying the rule objects to the input
     * XML.
     * &lt;p&gt;
     * If the digester stack was &quot;primed&quot; by explicitly pushing a root object onto the stack before parsing started,
     * then that root object is returned here.
     * &lt;p&gt;
     * Alternatively, if a Rule which creates an object (eg ObjectCreateRule) matched the root element of the xml, then
     * the object created will be returned here.
     * &lt;p&gt;
     * In other cases, the object most recently pushed onto an empty digester stack is returned. This would be a most
     * unusual use of digester, however; one of the previous configurations is much more likely.
     * &lt;p&gt;
     * Note that when using one of the Digester.parse methods, the return value from the parse method is exactly the
     * same as the return value from this method. However when the Digester is being used as a SAXContentHandler, no
     * such return value is available; in this case, this method allows you to access the root object that has been
     * created after parsing has completed.
     *
     * @param &lt;T&gt; the type used to auto-cast the returned object to the assigned variable type
     * @return the root object that has been created after parsing or null if the digester has not parsed any XML yet.
     */
    public &lt;T&gt; T getRoot()
    {
<span class="fc" id="L2866">        return this.&lt;T&gt; npeSafeCast( root );</span>
    }

    /**
     * This method allows the &quot;root&quot; variable to be reset to null.
     * &lt;p&gt;
     * It is not considered safe for a digester instance to be reused to parse multiple xml documents. However if you
     * are determined to do so, then you should call both clear() and resetRoot() before each parse.
     *
     * @since 1.7
     */
    public void resetRoot()
    {
<span class="nc" id="L2879">        root = null;</span>
<span class="nc" id="L2880">    }</span>

    // ------------------------------------------------ Parameter Stack Methods

    // ------------------------------------------------------ Protected Methods

    /**
     * &lt;p&gt;
     * Clean up allocated resources after parsing is complete. The default method closes input streams that have been
     * created by Digester itself. If you override this method in a subclass, be sure to call
     * &lt;code&gt;super.cleanup()&lt;/code&gt; to invoke this logic.
     * &lt;/p&gt;
     *
     * @since 1.8
     */
    protected void cleanup()
    {
        // If we created any InputSource objects in this instance,
        // they each have an input stream that should be closed
<span class="fc bfc" id="L2899" title="All 2 branches covered.">        for ( InputSource source : inputSources )</span>
        {
            try
            {
<span class="fc" id="L2903">                source.getByteStream().close();</span>
            }
<span class="nc" id="L2905">            catch ( IOException e )</span>
            {
                // Fall through so we get them all
<span class="nc bnc" id="L2908" title="All 2 branches missed.">                if ( log.isWarnEnabled() )</span>
                {
<span class="nc" id="L2910">                    log.warn( format( &quot;An error occurred while closing resource %s (%s)&quot;,</span>
<span class="nc" id="L2911">                                      source.getPublicId(),</span>
<span class="nc" id="L2912">                                      source.getSystemId() ), e );</span>
                }
<span class="fc" id="L2914">            }</span>
<span class="fc" id="L2915">        }</span>
<span class="fc" id="L2916">        inputSources.clear();</span>
<span class="fc" id="L2917">    }</span>

    /**
     * &lt;p&gt;
     * Provide a hook for lazy configuration of this &lt;code&gt;Digester&lt;/code&gt; instance. The default implementation does
     * nothing, but subclasses can override as needed.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note&lt;/strong&gt; This method may be called more than once. Once only initialization code should be placed in
     * {@link #initialize} or the code should take responsibility by checking and setting the {@link #configured} flag.
     * &lt;/p&gt;
     */
    protected void configure()
    {
        // Do not configure more than once
<span class="fc bfc" id="L2932" title="All 2 branches covered.">        if ( configured )</span>
        {
<span class="fc" id="L2934">            return;</span>
        }

        // Perform lazy configuration as needed
<span class="fc" id="L2938">        initialize(); // call hook method for subclasses that want to be initialized once only</span>
        // Nothing else required by default

        // Set the configuration flag to avoid repeating
<span class="fc" id="L2942">        configured = true;</span>
<span class="fc" id="L2943">    }</span>

    /**
     * Checks the Digester instance has been configured.
     *
     * @return true, if the Digester instance has been configured, false otherwise
     * @since 3.0
     */
    public boolean isConfigured()
    {
<span class="nc" id="L2953">        return configured;</span>
    }

    /**
     * &lt;p&gt;
     * Provides a hook for lazy initialization of this &lt;code&gt;Digester&lt;/code&gt; instance. The default implementation does
     * nothing, but subclasses can override as needed. Digester (by default) only calls this method once.
     * &lt;/p&gt;
     * &lt;p&gt;
     * &lt;strong&gt;Note&lt;/strong&gt; This method will be called by {@link #configure} only when the {@link #configured} flag is
     * false. Subclasses that override &lt;code&gt;configure&lt;/code&gt; or who set &lt;code&gt;configured&lt;/code&gt; may find that this
     * method may be called more than once.
     * &lt;/p&gt;
     *
     * @since 1.6
     */
    protected void initialize()
    {
        // Perform lazy initialization as needed
        // Nothing required by default
<span class="fc" id="L2973">    }</span>

    // -------------------------------------------------------- Package Methods

    /**
     * Return the set of DTD URL registrations, keyed by public identifier. NOTE: the returned map is in read-only mode.
     *
     * @return the read-only Map of DTD URL registrations.
     */
    Map&lt;String, URL&gt; getRegistrations()
    {
<span class="fc" id="L2984">        return Collections.unmodifiableMap( entityValidator );</span>
    }

    /**
     * &lt;p&gt;
     * Return the top object on the parameters stack without removing it. If there are no objects on the stack, return
     * &lt;code&gt;null&lt;/code&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. See {@link #params}.
     * &lt;/p&gt;
     *
     * @return the top object on the parameters stack without removing it.
     */
    public Object[] peekParams()
    {
        try
        {
<span class="fc" id="L3002">            return ( params.peek() );</span>
        }
<span class="nc" id="L3004">        catch ( EmptyStackException e )</span>
        {
<span class="nc" id="L3006">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="nc" id="L3007">            return ( null );</span>
        }
    }

    /**
     * &lt;p&gt;
     * Return the n'th object down the parameters stack, where 0 is the top element and [getCount()-1] is the bottom
     * element. If the specified index is out of range, return &lt;code&gt;null&lt;/code&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. See {@link #params}.
     * &lt;/p&gt;
     *
     * @param n Index of the desired element, where 0 is the top of the stack, 1 is the next element down, and so on.
     * @return the n'th object down the parameters stack
     */
    public Object[] peekParams( int n )
    {
<span class="nc" id="L3025">        int index = ( params.size() - 1 ) - n;</span>
<span class="nc bnc" id="L3026" title="All 2 branches missed.">        if ( index &lt; 0 )</span>
        {
<span class="nc" id="L3028">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="nc" id="L3029">            return ( null );</span>
        }
        try
        {
<span class="nc" id="L3033">            return ( params.get( index ) );</span>
        }
<span class="nc" id="L3035">        catch ( EmptyStackException e )</span>
        {
<span class="nc" id="L3037">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="nc" id="L3038">            return ( null );</span>
        }
    }

    /**
     * &lt;p&gt;
     * Pop the top object off of the parameters stack, and return it. If there are no objects on the stack, return
     * &lt;code&gt;null&lt;/code&gt;.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. See {@link #params}.
     * &lt;/p&gt;
     *
     * @return the top object popped off of the parameters stack
     */
    public Object[] popParams()
    {
        try
        {
<span class="pc bpc" id="L3057" title="1 of 2 branches missed.">            if ( log.isTraceEnabled() )</span>
            {
<span class="nc" id="L3059">                log.trace( &quot;Popping params&quot; );</span>
            }
<span class="fc" id="L3061">            return ( params.pop() );</span>
        }
<span class="nc" id="L3063">        catch ( EmptyStackException e )</span>
        {
<span class="nc" id="L3065">            log.warn( &quot;Empty stack (returning null)&quot; );</span>
<span class="nc" id="L3066">            return ( null );</span>
        }
    }

    /**
     * &lt;p&gt;
     * Push a new object onto the top of the parameters stack.
     * &lt;/p&gt;
     * &lt;p&gt;
     * The parameters stack is used to store &lt;code&gt;CallMethodRule&lt;/code&gt; parameters. See {@link #params}.
     * &lt;/p&gt;
     *
     * @param object The new object
     */
    public void pushParams( Object... object )
    {
<span class="pc bpc" id="L3082" title="1 of 2 branches missed.">        if ( log.isTraceEnabled() )</span>
        {
<span class="nc" id="L3084">            log.trace( &quot;Pushing params&quot; );</span>
        }
<span class="fc" id="L3086">        params.push( object );</span>
<span class="fc" id="L3087">    }</span>

    /**
     * Create a SAX exception which also understands about the location in the digester file where the exception occurs
     *
     * @param message the custom SAX exception message
     * @param e the exception cause
     * @return the new SAX exception
     */
    public SAXException createSAXException( String message, Exception e )
    {
<span class="pc bpc" id="L3098" title="2 of 4 branches missed.">        if ( ( e != null ) &amp;&amp; ( e instanceof InvocationTargetException ) )</span>
        {
<span class="nc" id="L3100">            Throwable t = ( (InvocationTargetException) e ).getTargetException();</span>
<span class="nc bnc" id="L3101" title="All 4 branches missed.">            if ( ( t != null ) &amp;&amp; ( t instanceof Exception ) )</span>
            {
<span class="nc" id="L3103">                e = (Exception) t;</span>
            }
        }
<span class="pc bpc" id="L3106" title="1 of 2 branches missed.">        if ( locator != null )</span>
        {
<span class="fc" id="L3108">            String error =</span>
<span class="fc" id="L3109">                &quot;Error at line &quot; + locator.getLineNumber() + &quot; char &quot; + locator.getColumnNumber() + &quot;: &quot; + message;</span>
<span class="pc bpc" id="L3110" title="1 of 2 branches missed.">            if ( e != null )</span>
            {
<span class="fc" id="L3112">                return new SAXParseException( error, locator, e );</span>
            }
<span class="nc" id="L3114">            return new SAXParseException( error, locator );</span>
        }
<span class="nc" id="L3116">        log.error( &quot;No Locator!&quot; );</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">        if ( e != null )</span>
        {
<span class="nc" id="L3119">            return new SAXException( message, e );</span>
        }
<span class="nc" id="L3121">        return new SAXException( message );</span>
    }

    /**
     * Create a SAX exception which also understands about the location in the digester file where the exception occurs
     *
     * @param e the exception cause
     * @return the new SAX exception
     */
    public SAXException createSAXException( Exception e )
    {
<span class="pc bpc" id="L3132" title="1 of 2 branches missed.">        if ( e instanceof InvocationTargetException )</span>
        {
<span class="nc" id="L3134">            Throwable t = ( (InvocationTargetException) e ).getTargetException();</span>
<span class="nc bnc" id="L3135" title="All 4 branches missed.">            if ( ( t != null ) &amp;&amp; ( t instanceof Exception ) )</span>
            {
<span class="nc" id="L3137">                e = (Exception) t;</span>
            }
        }
<span class="fc" id="L3140">        return createSAXException( e.getMessage(), e );</span>
    }

    /**
     * Create a SAX exception which also understands about the location in the digester file where the exception occurs
     *
     * @param message the custom SAX exception message
     * @return the new SAX exception
     */
    public SAXException createSAXException( String message )
    {
<span class="nc" id="L3151">        return createSAXException( message, null );</span>
    }

    /**
     * Helps casting the input object to given type, avoiding NPEs.
     *
     * @since 3.0
     * @param &lt;T&gt; the type the input object has to be cast.
     * @param obj the object has to be cast.
     * @return the casted object, if input object is not null, null otherwise.
     */
    private &lt;T&gt; T npeSafeCast( Object obj )
    {
<span class="fc bfc" id="L3164" title="All 2 branches covered.">        if ( obj == null )</span>
        {
<span class="fc" id="L3166">            return null;</span>
        }

        @SuppressWarnings( &quot;unchecked&quot; )
<span class="fc" id="L3170">        T result = (T) obj;</span>
<span class="fc" id="L3171">        return result;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.3.201901230119</span></div></body></html>